{"ast":null,"code":"import { __extends, __assign, __awaiter, __generator } from 'tslib';\nimport { getOperationDefinition, isEqual, tryFunctionOrLogError, cloneDeep, mergeDeep, hasDirectives, removeClientSetsFromDocument, buildQueryFromSelectionSet, getMainDefinition, getFragmentDefinitions, createFragmentMap, mergeDeepArray, resultKeyNameFromField, argumentsObjectFromField, shouldInclude, isField, isInlineFragment, canUseWeakMap, graphQLResultHasError, removeConnectionDirectiveFromDocument, hasClientExports, getDefaultValues, getOperationName } from 'apollo-utilities';\nimport { Observable as Observable$1, execute, ApolloLink } from 'apollo-link';\nimport $$observable from 'symbol-observable';\nimport { InvariantError, invariant } from 'ts-invariant';\nimport { visit, BREAK } from 'graphql/language/visitor';\nvar NetworkStatus;\n\n(function (NetworkStatus) {\n  NetworkStatus[NetworkStatus[\"loading\"] = 1] = \"loading\";\n  NetworkStatus[NetworkStatus[\"setVariables\"] = 2] = \"setVariables\";\n  NetworkStatus[NetworkStatus[\"fetchMore\"] = 3] = \"fetchMore\";\n  NetworkStatus[NetworkStatus[\"refetch\"] = 4] = \"refetch\";\n  NetworkStatus[NetworkStatus[\"poll\"] = 6] = \"poll\";\n  NetworkStatus[NetworkStatus[\"ready\"] = 7] = \"ready\";\n  NetworkStatus[NetworkStatus[\"error\"] = 8] = \"error\";\n})(NetworkStatus || (NetworkStatus = {}));\n\nfunction isNetworkRequestInFlight(networkStatus) {\n  return networkStatus < 7;\n}\n\nvar Observable = function (_super) {\n  __extends(Observable, _super);\n\n  function Observable() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Observable.prototype[$$observable] = function () {\n    return this;\n  };\n\n  Observable.prototype['@@observable'] = function () {\n    return this;\n  };\n\n  return Observable;\n}(Observable$1);\n\nfunction isNonEmptyArray(value) {\n  return Array.isArray(value) && value.length > 0;\n}\n\nfunction isApolloError(err) {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\nvar generateErrorMessage = function (err) {\n  var message = '';\n\n  if (isNonEmptyArray(err.graphQLErrors)) {\n    err.graphQLErrors.forEach(function (graphQLError) {\n      var errorMessage = graphQLError ? graphQLError.message : 'Error message not found.';\n      message += \"GraphQL error: \" + errorMessage + \"\\n\";\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nvar ApolloError = function (_super) {\n  __extends(ApolloError, _super);\n\n  function ApolloError(_a) {\n    var graphQLErrors = _a.graphQLErrors,\n        networkError = _a.networkError,\n        errorMessage = _a.errorMessage,\n        extraInfo = _a.extraInfo;\n\n    var _this = _super.call(this, errorMessage) || this;\n\n    _this.graphQLErrors = graphQLErrors || [];\n    _this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      _this.message = generateErrorMessage(_this);\n    } else {\n      _this.message = errorMessage;\n    }\n\n    _this.extraInfo = extraInfo;\n    _this.__proto__ = ApolloError.prototype;\n    return _this;\n  }\n\n  return ApolloError;\n}(Error);\n\nvar FetchType;\n\n(function (FetchType) {\n  FetchType[FetchType[\"normal\"] = 1] = \"normal\";\n  FetchType[FetchType[\"refetch\"] = 2] = \"refetch\";\n  FetchType[FetchType[\"poll\"] = 3] = \"poll\";\n})(FetchType || (FetchType = {}));\n\nvar hasError = function (storeValue, policy) {\n  if (policy === void 0) {\n    policy = 'none';\n  }\n\n  return storeValue && (storeValue.networkError || policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors));\n};\n\nvar ObservableQuery = function (_super) {\n  __extends(ObservableQuery, _super);\n\n  function ObservableQuery(_a) {\n    var queryManager = _a.queryManager,\n        options = _a.options,\n        _b = _a.shouldSubscribe,\n        shouldSubscribe = _b === void 0 ? true : _b;\n\n    var _this = _super.call(this, function (observer) {\n      return _this.onSubscribe(observer);\n    }) || this;\n\n    _this.observers = new Set();\n    _this.subscriptions = new Set();\n    _this.isTornDown = false;\n    _this.options = options;\n    _this.variables = options.variables || {};\n    _this.queryId = queryManager.generateQueryId();\n    _this.shouldSubscribe = shouldSubscribe;\n    var opDef = getOperationDefinition(options.query);\n    _this.queryName = opDef && opDef.name && opDef.name.value;\n    _this.queryManager = queryManager;\n    return _this;\n  }\n\n  ObservableQuery.prototype.result = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var observer = {\n        next: function (result) {\n          resolve(result);\n\n          _this.observers.delete(observer);\n\n          if (!_this.observers.size) {\n            _this.queryManager.removeQuery(_this.queryId);\n          }\n\n          setTimeout(function () {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject\n      };\n\n      var subscription = _this.subscribe(observer);\n    });\n  };\n\n  ObservableQuery.prototype.currentResult = function () {\n    var result = this.getCurrentResult();\n\n    if (result.data === undefined) {\n      result.data = {};\n    }\n\n    return result;\n  };\n\n  ObservableQuery.prototype.getCurrentResult = function () {\n    if (this.isTornDown) {\n      var lastResult = this.lastResult;\n      return {\n        data: !this.lastError && lastResult && lastResult.data || void 0,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error\n      };\n    }\n\n    var _a = this.queryManager.getCurrentQueryResult(this),\n        data = _a.data,\n        partial = _a.partial;\n\n    var queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n    var result;\n    var fetchPolicy = this.options.fetchPolicy;\n    var isNetworkFetchPolicy = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n\n    if (queryStoreValue) {\n      var networkStatus = queryStoreValue.networkStatus;\n\n      if (hasError(queryStoreValue, this.options.errorPolicy)) {\n        return {\n          data: void 0,\n          loading: false,\n          networkStatus: networkStatus,\n          error: new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError\n          })\n        };\n      }\n\n      if (queryStoreValue.variables) {\n        this.options.variables = __assign(__assign({}, this.options.variables), queryStoreValue.variables);\n        this.variables = this.options.variables;\n      }\n\n      result = {\n        data: data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus: networkStatus\n      };\n\n      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n        result.errors = queryStoreValue.graphQLErrors;\n      }\n    } else {\n      var loading = isNetworkFetchPolicy || partial && fetchPolicy !== 'cache-only';\n      result = {\n        data: data,\n        loading: loading,\n        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready\n      };\n    }\n\n    if (!partial) {\n      this.updateLastResult(__assign(__assign({}, result), {\n        stale: false\n      }));\n    }\n\n    return __assign(__assign({}, result), {\n      partial: partial\n    });\n  };\n\n  ObservableQuery.prototype.isDifferentFromLastResult = function (newResult) {\n    var snapshot = this.lastResultSnapshot;\n    return !(snapshot && newResult && snapshot.networkStatus === newResult.networkStatus && snapshot.stale === newResult.stale && isEqual(snapshot.data, newResult.data));\n  };\n\n  ObservableQuery.prototype.getLastResult = function () {\n    return this.lastResult;\n  };\n\n  ObservableQuery.prototype.getLastError = function () {\n    return this.lastError;\n  };\n\n  ObservableQuery.prototype.resetLastResults = function () {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  };\n\n  ObservableQuery.prototype.resetQueryStoreErrors = function () {\n    var queryStore = this.queryManager.queryStore.get(this.queryId);\n\n    if (queryStore) {\n      queryStore.networkError = null;\n      queryStore.graphQLErrors = [];\n    }\n  };\n\n  ObservableQuery.prototype.refetch = function (variables) {\n    var fetchPolicy = this.options.fetchPolicy;\n\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(process.env.NODE_ENV === \"production\" ? new InvariantError(1) : new InvariantError('cache-only fetchPolicy option should not be used together with query refetch.'));\n    }\n\n    if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'cache-and-network') {\n      fetchPolicy = 'network-only';\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      this.variables = __assign(__assign({}, this.variables), variables);\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      this.options.variables = __assign(__assign({}, this.options.variables), this.variables);\n    }\n\n    return this.queryManager.fetchQuery(this.queryId, __assign(__assign({}, this.options), {\n      fetchPolicy: fetchPolicy\n    }), FetchType.refetch);\n  };\n\n  ObservableQuery.prototype.fetchMore = function (fetchMoreOptions) {\n    var _this = this;\n\n    process.env.NODE_ENV === \"production\" ? invariant(fetchMoreOptions.updateQuery, 2) : invariant(fetchMoreOptions.updateQuery, 'updateQuery option is required. This function defines how to update the query data with the new results.');\n\n    var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign({}, this.options), fetchMoreOptions), {\n      variables: __assign(__assign({}, this.variables), fetchMoreOptions.variables)\n    })), {\n      fetchPolicy: 'network-only'\n    });\n\n    var qid = this.queryManager.generateQueryId();\n    return this.queryManager.fetchQuery(qid, combinedOptions, FetchType.normal, this.queryId).then(function (fetchMoreResult) {\n      _this.updateQuery(function (previousResult) {\n        return fetchMoreOptions.updateQuery(previousResult, {\n          fetchMoreResult: fetchMoreResult.data,\n          variables: combinedOptions.variables\n        });\n      });\n\n      _this.queryManager.stopQuery(qid);\n\n      return fetchMoreResult;\n    }, function (error) {\n      _this.queryManager.stopQuery(qid);\n\n      throw error;\n    });\n  };\n\n  ObservableQuery.prototype.subscribeToMore = function (options) {\n    var _this = this;\n\n    var subscription = this.queryManager.startGraphQLSubscription({\n      query: options.document,\n      variables: options.variables\n    }).subscribe({\n      next: function (subscriptionData) {\n        var updateQuery = options.updateQuery;\n\n        if (updateQuery) {\n          _this.updateQuery(function (previous, _a) {\n            var variables = _a.variables;\n            return updateQuery(previous, {\n              subscriptionData: subscriptionData,\n              variables: variables\n            });\n          });\n        }\n      },\n      error: function (err) {\n        if (options.onError) {\n          options.onError(err);\n          return;\n        }\n\n        process.env.NODE_ENV === \"production\" || invariant.error('Unhandled GraphQL subscription error', err);\n      }\n    });\n    this.subscriptions.add(subscription);\n    return function () {\n      if (_this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  };\n\n  ObservableQuery.prototype.setOptions = function (opts) {\n    var oldFetchPolicy = this.options.fetchPolicy;\n    this.options = __assign(__assign({}, this.options), opts);\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    var fetchPolicy = opts.fetchPolicy;\n    return this.setVariables(this.options.variables, oldFetchPolicy !== fetchPolicy && (oldFetchPolicy === 'cache-only' || oldFetchPolicy === 'standby' || fetchPolicy === 'network-only'), opts.fetchResults);\n  };\n\n  ObservableQuery.prototype.setVariables = function (variables, tryFetch, fetchResults) {\n    if (tryFetch === void 0) {\n      tryFetch = false;\n    }\n\n    if (fetchResults === void 0) {\n      fetchResults = true;\n    }\n\n    this.isTornDown = false;\n    variables = variables || this.variables;\n\n    if (!tryFetch && isEqual(variables, this.variables)) {\n      return this.observers.size && fetchResults ? this.result() : Promise.resolve();\n    }\n\n    this.variables = this.options.variables = variables;\n\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    return this.queryManager.fetchQuery(this.queryId, this.options);\n  };\n\n  ObservableQuery.prototype.updateQuery = function (mapFn) {\n    var queryManager = this.queryManager;\n\n    var _a = queryManager.getQueryWithPreviousResult(this.queryId),\n        previousResult = _a.previousResult,\n        variables = _a.variables,\n        document = _a.document;\n\n    var newResult = tryFunctionOrLogError(function () {\n      return mapFn(previousResult, {\n        variables: variables\n      });\n    });\n\n    if (newResult) {\n      queryManager.dataStore.markUpdateQueryResult(document, variables, newResult);\n      queryManager.broadcastQueries();\n    }\n  };\n\n  ObservableQuery.prototype.stopPolling = function () {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  };\n\n  ObservableQuery.prototype.startPolling = function (pollInterval) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  };\n\n  ObservableQuery.prototype.updateLastResult = function (newResult) {\n    var previousResult = this.lastResult;\n    this.lastResult = newResult;\n    this.lastResultSnapshot = this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult);\n    return previousResult;\n  };\n\n  ObservableQuery.prototype.onSubscribe = function (observer) {\n    var _this = this;\n\n    try {\n      var subObserver = observer._subscription._observer;\n\n      if (subObserver && !subObserver.error) {\n        subObserver.error = defaultSubscriptionObserverErrorCallback;\n      }\n    } catch (_a) {}\n\n    var first = !this.observers.size;\n    this.observers.add(observer);\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    if (first) {\n      this.setUpQuery();\n    }\n\n    return function () {\n      if (_this.observers.delete(observer) && !_this.observers.size) {\n        _this.tearDownQuery();\n      }\n    };\n  };\n\n  ObservableQuery.prototype.setUpQuery = function () {\n    var _this = this;\n\n    var _a = this,\n        queryManager = _a.queryManager,\n        queryId = _a.queryId;\n\n    if (this.shouldSubscribe) {\n      queryManager.addObservableQuery(queryId, this);\n    }\n\n    if (this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      queryManager.startPollingQuery(this.options, queryId);\n    }\n\n    var onError = function (error) {\n      _this.updateLastResult(__assign(__assign({}, _this.lastResult), {\n        errors: error.graphQLErrors,\n        networkStatus: NetworkStatus.error,\n        loading: false\n      }));\n\n      iterateObserversSafely(_this.observers, 'error', _this.lastError = error);\n    };\n\n    queryManager.observeQuery(queryId, this.options, {\n      next: function (result) {\n        if (_this.lastError || _this.isDifferentFromLastResult(result)) {\n          var previousResult_1 = _this.updateLastResult(result);\n\n          var _a = _this.options,\n              query_1 = _a.query,\n              variables = _a.variables,\n              fetchPolicy_1 = _a.fetchPolicy;\n\n          if (queryManager.transform(query_1).hasClientExports) {\n            queryManager.getLocalState().addExportedVariables(query_1, variables).then(function (variables) {\n              var previousVariables = _this.variables;\n              _this.variables = _this.options.variables = variables;\n\n              if (!result.loading && previousResult_1 && fetchPolicy_1 !== 'cache-only' && queryManager.transform(query_1).serverQuery && !isEqual(previousVariables, variables)) {\n                _this.refetch();\n              } else {\n                iterateObserversSafely(_this.observers, 'next', result);\n              }\n            });\n          } else {\n            iterateObserversSafely(_this.observers, 'next', result);\n          }\n        }\n      },\n      error: onError\n    }).catch(onError);\n  };\n\n  ObservableQuery.prototype.tearDownQuery = function () {\n    var queryManager = this.queryManager;\n    this.isTornDown = true;\n    queryManager.stopPollingQuery(this.queryId);\n    this.subscriptions.forEach(function (sub) {\n      return sub.unsubscribe();\n    });\n    this.subscriptions.clear();\n    queryManager.removeObservableQuery(this.queryId);\n    queryManager.stopQuery(this.queryId);\n    this.observers.clear();\n  };\n\n  return ObservableQuery;\n}(Observable);\n\nfunction defaultSubscriptionObserverErrorCallback(error) {\n  process.env.NODE_ENV === \"production\" || invariant.error('Unhandled error', error.message, error.stack);\n}\n\nfunction iterateObserversSafely(observers, method, argument) {\n  var observersWithMethod = [];\n  observers.forEach(function (obs) {\n    return obs[method] && observersWithMethod.push(obs);\n  });\n  observersWithMethod.forEach(function (obs) {\n    return obs[method](argument);\n  });\n}\n\nfunction assertNotCacheFirstOrOnly(obsQuery) {\n  var fetchPolicy = obsQuery.options.fetchPolicy;\n  process.env.NODE_ENV === \"production\" ? invariant(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 3) : invariant(fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only', 'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.');\n}\n\nvar MutationStore = function () {\n  function MutationStore() {\n    this.store = {};\n  }\n\n  MutationStore.prototype.getStore = function () {\n    return this.store;\n  };\n\n  MutationStore.prototype.get = function (mutationId) {\n    return this.store[mutationId];\n  };\n\n  MutationStore.prototype.initMutation = function (mutationId, mutation, variables) {\n    this.store[mutationId] = {\n      mutation: mutation,\n      variables: variables || {},\n      loading: true,\n      error: null\n    };\n  };\n\n  MutationStore.prototype.markMutationError = function (mutationId, error) {\n    var mutation = this.store[mutationId];\n\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = error;\n    }\n  };\n\n  MutationStore.prototype.markMutationResult = function (mutationId) {\n    var mutation = this.store[mutationId];\n\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = null;\n    }\n  };\n\n  MutationStore.prototype.reset = function () {\n    this.store = {};\n  };\n\n  return MutationStore;\n}();\n\nvar QueryStore = function () {\n  function QueryStore() {\n    this.store = {};\n  }\n\n  QueryStore.prototype.getStore = function () {\n    return this.store;\n  };\n\n  QueryStore.prototype.get = function (queryId) {\n    return this.store[queryId];\n  };\n\n  QueryStore.prototype.initQuery = function (query) {\n    var previousQuery = this.store[query.queryId];\n    process.env.NODE_ENV === \"production\" ? invariant(!previousQuery || previousQuery.document === query.document || isEqual(previousQuery.document, query.document), 19) : invariant(!previousQuery || previousQuery.document === query.document || isEqual(previousQuery.document, query.document), 'Internal Error: may not update existing query string in store');\n    var isSetVariables = false;\n    var previousVariables = null;\n\n    if (query.storePreviousVariables && previousQuery && previousQuery.networkStatus !== NetworkStatus.loading) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    var networkStatus;\n\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    var graphQLErrors = [];\n\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables: previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus: networkStatus,\n      metadata: query.metadata\n    };\n\n    if (typeof query.fetchMoreForQueryId === 'string' && this.store[query.fetchMoreForQueryId]) {\n      this.store[query.fetchMoreForQueryId].networkStatus = NetworkStatus.fetchMore;\n    }\n  };\n\n  QueryStore.prototype.markQueryResult = function (queryId, result, fetchMoreForQueryId) {\n    if (!this.store || !this.store[queryId]) return;\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    if (typeof fetchMoreForQueryId === 'string' && this.store[fetchMoreForQueryId]) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  };\n\n  QueryStore.prototype.markQueryError = function (queryId, error, fetchMoreForQueryId) {\n    if (!this.store || !this.store[queryId]) return;\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  };\n\n  QueryStore.prototype.markQueryResultClient = function (queryId, complete) {\n    var storeValue = this.store && this.store[queryId];\n\n    if (storeValue) {\n      storeValue.networkError = null;\n      storeValue.previousVariables = null;\n\n      if (complete) {\n        storeValue.networkStatus = NetworkStatus.ready;\n      }\n    }\n  };\n\n  QueryStore.prototype.stopQuery = function (queryId) {\n    delete this.store[queryId];\n  };\n\n  QueryStore.prototype.reset = function (observableQueryIds) {\n    var _this = this;\n\n    Object.keys(this.store).forEach(function (queryId) {\n      if (observableQueryIds.indexOf(queryId) < 0) {\n        _this.stopQuery(queryId);\n      } else {\n        _this.store[queryId].networkStatus = NetworkStatus.loading;\n      }\n    });\n  };\n\n  return QueryStore;\n}();\n\nfunction capitalizeFirstLetter(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nvar LocalState = function () {\n  function LocalState(_a) {\n    var cache = _a.cache,\n        client = _a.client,\n        resolvers = _a.resolvers,\n        fragmentMatcher = _a.fragmentMatcher;\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  LocalState.prototype.addResolvers = function (resolvers) {\n    var _this = this;\n\n    this.resolvers = this.resolvers || {};\n\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(function (resolverGroup) {\n        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  };\n\n  LocalState.prototype.setResolvers = function (resolvers) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  };\n\n  LocalState.prototype.getResolvers = function () {\n    return this.resolvers || {};\n  };\n\n  LocalState.prototype.runResolvers = function (_a) {\n    var document = _a.document,\n        remoteResult = _a.remoteResult,\n        context = _a.context,\n        variables = _a.variables,\n        _b = _a.onlyRunForcedResolvers,\n        onlyRunForcedResolvers = _b === void 0 ? false : _b;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_c) {\n        if (document) {\n          return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {\n            return __assign(__assign({}, remoteResult), {\n              data: localResult.result\n            });\n          })];\n        }\n\n        return [2, remoteResult];\n      });\n    });\n  };\n\n  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  };\n\n  LocalState.prototype.getFragmentMatcher = function () {\n    return this.fragmentMatcher;\n  };\n\n  LocalState.prototype.clientQuery = function (document) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n\n      process.env.NODE_ENV === \"production\" || invariant.warn('Found @client directives in a query but no ApolloClient resolvers ' + 'were specified. This means ApolloClient local resolver handling ' + 'has been disabled, and @client directives will be passed through ' + 'to your link chain.');\n    }\n\n    return null;\n  };\n\n  LocalState.prototype.serverQuery = function (document) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  };\n\n  LocalState.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    var cache = this.cache;\n\n    var newContext = __assign(__assign({}, context), {\n      cache: cache,\n      getCacheKey: function (obj) {\n        if (cache.config) {\n          return cache.config.dataIdFromObject(obj);\n        } else {\n          process.env.NODE_ENV === \"production\" ? invariant(false, 6) : invariant(false, 'To use context.getCacheKey, you need to use a cache that has ' + 'a configurable dataIdFromObject, like apollo-cache-inmemory.');\n        }\n      }\n    });\n\n    return newContext;\n  };\n\n  LocalState.prototype.addExportedVariables = function (document, variables, context) {\n    if (variables === void 0) {\n      variables = {};\n    }\n\n    if (context === void 0) {\n      context = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (document) {\n          return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {\n            return __assign(__assign({}, variables), data.exportedVariables);\n          })];\n        }\n\n        return [2, __assign({}, variables)];\n      });\n    });\n  };\n\n  LocalState.prototype.shouldForceResolvers = function (document) {\n    var forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter: function (node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(function (arg) {\n              return arg.name.value === 'always' && arg.value.kind === 'BooleanValue' && arg.value.value === true;\n            });\n\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        }\n      }\n    });\n    return forceResolvers;\n  };\n\n  LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables: variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n  };\n\n  LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    if (variables === void 0) {\n      variables = {};\n    }\n\n    if (fragmentMatcher === void 0) {\n      fragmentMatcher = function () {\n        return true;\n      };\n    }\n\n    if (onlyRunForcedResolvers === void 0) {\n      onlyRunForcedResolvers = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;\n\n      return __generator(this, function (_b) {\n        mainDefinition = getMainDefinition(document);\n        fragments = getFragmentDefinitions(document);\n        fragmentMap = createFragmentMap(fragments);\n        definitionOperation = mainDefinition.operation;\n        defaultOperationType = definitionOperation ? capitalizeFirstLetter(definitionOperation) : 'Query';\n        _a = this, cache = _a.cache, client = _a.client;\n        execContext = {\n          fragmentMap: fragmentMap,\n          context: __assign(__assign({}, context), {\n            cache: cache,\n            client: client\n          }),\n          variables: variables,\n          fragmentMatcher: fragmentMatcher,\n          defaultOperationType: defaultOperationType,\n          exportedVariables: {},\n          onlyRunForcedResolvers: onlyRunForcedResolvers\n        };\n        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) {\n          return {\n            result: result,\n            exportedVariables: execContext.exportedVariables\n          };\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fragmentMap, context, variables, resultsToMerge, execute;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n        resultsToMerge = [rootValue];\n\n        execute = function (selection) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var fragment, typeCondition;\n            return __generator(this, function (_a) {\n              if (!shouldInclude(selection, variables)) {\n                return [2];\n              }\n\n              if (isField(selection)) {\n                return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {\n                  var _a;\n\n                  if (typeof fieldResult !== 'undefined') {\n                    resultsToMerge.push((_a = {}, _a[resultKeyNameFromField(selection)] = fieldResult, _a));\n                  }\n                })];\n              }\n\n              if (isInlineFragment(selection)) {\n                fragment = selection;\n              } else {\n                fragment = fragmentMap[selection.name.value];\n                process.env.NODE_ENV === \"production\" ? invariant(fragment, 7) : invariant(fragment, \"No fragment named \" + selection.name.value);\n              }\n\n              if (fragment && fragment.typeCondition) {\n                typeCondition = fragment.typeCondition.name.value;\n\n                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {\n                    resultsToMerge.push(fragmentResult);\n                  })];\n                }\n              }\n\n              return [2];\n            });\n          });\n        };\n\n        return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {\n          return mergeDeepArray(resultsToMerge);\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveField = function (field, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        variables = execContext.variables;\n        fieldName = field.name.value;\n        aliasedFieldName = resultKeyNameFromField(field);\n        aliasUsed = fieldName !== aliasedFieldName;\n        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n        resultPromise = Promise.resolve(defaultResult);\n\n        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n          resolverType = rootValue.__typename || execContext.defaultOperationType;\n          resolverMap = this.resolvers && this.resolvers[resolverType];\n\n          if (resolverMap) {\n            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n\n            if (resolve) {\n              resultPromise = Promise.resolve(resolve(rootValue, argumentsObjectFromField(field, variables), execContext.context, {\n                field: field,\n                fragmentMap: execContext.fragmentMap\n              }));\n            }\n          }\n        }\n\n        return [2, resultPromise.then(function (result) {\n          if (result === void 0) {\n            result = defaultResult;\n          }\n\n          if (field.directives) {\n            field.directives.forEach(function (directive) {\n              if (directive.name.value === 'export' && directive.arguments) {\n                directive.arguments.forEach(function (arg) {\n                  if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                    execContext.exportedVariables[arg.value.value] = result;\n                  }\n                });\n              }\n            });\n          }\n\n          if (!field.selectionSet) {\n            return result;\n          }\n\n          if (result == null) {\n            return result;\n          }\n\n          if (Array.isArray(result)) {\n            return _this.resolveSubSelectedArray(field, result, execContext);\n          }\n\n          if (field.selectionSet) {\n            return _this.resolveSelectionSet(field.selectionSet, result, execContext);\n          }\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {\n    var _this = this;\n\n    return Promise.all(result.map(function (item) {\n      if (item === null) {\n        return null;\n      }\n\n      if (Array.isArray(item)) {\n        return _this.resolveSubSelectedArray(field, item, execContext);\n      }\n\n      if (field.selectionSet) {\n        return _this.resolveSelectionSet(field.selectionSet, item, execContext);\n      }\n    }));\n  };\n\n  return LocalState;\n}();\n\nfunction multiplex(inner) {\n  var observers = new Set();\n  var sub = null;\n  return new Observable(function (observer) {\n    observers.add(observer);\n    sub = sub || inner.subscribe({\n      next: function (value) {\n        observers.forEach(function (obs) {\n          return obs.next && obs.next(value);\n        });\n      },\n      error: function (error) {\n        observers.forEach(function (obs) {\n          return obs.error && obs.error(error);\n        });\n      },\n      complete: function () {\n        observers.forEach(function (obs) {\n          return obs.complete && obs.complete();\n        });\n      }\n    });\n    return function () {\n      if (observers.delete(observer) && !observers.size && sub) {\n        sub.unsubscribe();\n        sub = null;\n      }\n    };\n  });\n}\n\nfunction asyncMap(observable, mapFn) {\n  return new Observable(function (observer) {\n    var next = observer.next,\n        error = observer.error,\n        complete = observer.complete;\n    var activeNextCount = 0;\n    var completed = false;\n    var handler = {\n      next: function (value) {\n        ++activeNextCount;\n        new Promise(function (resolve) {\n          resolve(mapFn(value));\n        }).then(function (result) {\n          --activeNextCount;\n          next && next.call(observer, result);\n          completed && handler.complete();\n        }, function (e) {\n          --activeNextCount;\n          error && error.call(observer, e);\n        });\n      },\n      error: function (e) {\n        error && error.call(observer, e);\n      },\n      complete: function () {\n        completed = true;\n\n        if (!activeNextCount) {\n          complete && complete.call(observer);\n        }\n      }\n    };\n    var sub = observable.subscribe(handler);\n    return function () {\n      return sub.unsubscribe();\n    };\n  });\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar QueryManager = function () {\n  function QueryManager(_a) {\n    var link = _a.link,\n        _b = _a.queryDeduplication,\n        queryDeduplication = _b === void 0 ? false : _b,\n        store = _a.store,\n        _c = _a.onBroadcast,\n        onBroadcast = _c === void 0 ? function () {\n      return undefined;\n    } : _c,\n        _d = _a.ssrMode,\n        ssrMode = _d === void 0 ? false : _d,\n        _e = _a.clientAwareness,\n        clientAwareness = _e === void 0 ? {} : _e,\n        localState = _a.localState,\n        assumeImmutableResults = _a.assumeImmutableResults;\n    this.mutationStore = new MutationStore();\n    this.queryStore = new QueryStore();\n    this.clientAwareness = {};\n    this.idCounter = 1;\n    this.queries = new Map();\n    this.fetchQueryRejectFns = new Map();\n    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();\n    this.inFlightLinkObservables = new Map();\n    this.pollingInfoByQueryId = new Map();\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({\n      cache: store.getCache()\n    });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n  }\n\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.fetchQueryRejectFns.forEach(function (reject) {\n      reject(process.env.NODE_ENV === \"production\" ? new InvariantError(8) : new InvariantError('QueryManager stopped while query was in flight'));\n    });\n  };\n\n  QueryManager.prototype.mutate = function (_a) {\n    var mutation = _a.mutation,\n        variables = _a.variables,\n        optimisticResponse = _a.optimisticResponse,\n        updateQueriesByName = _a.updateQueries,\n        _b = _a.refetchQueries,\n        refetchQueries = _b === void 0 ? [] : _b,\n        _c = _a.awaitRefetchQueries,\n        awaitRefetchQueries = _c === void 0 ? false : _c,\n        updateWithProxyFn = _a.update,\n        _d = _a.errorPolicy,\n        errorPolicy = _d === void 0 ? 'none' : _d,\n        fetchPolicy = _a.fetchPolicy,\n        _e = _a.context,\n        context = _e === void 0 ? {} : _e;\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationId, generateUpdateQueriesInfo, self;\n\n      var _this = this;\n\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            process.env.NODE_ENV === \"production\" ? invariant(mutation, 9) : invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.');\n            process.env.NODE_ENV === \"production\" ? invariant(!fetchPolicy || fetchPolicy === 'no-cache', 10) : invariant(!fetchPolicy || fetchPolicy === 'no-cache', \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\");\n            mutationId = this.generateQueryId();\n            mutation = this.transform(mutation).document;\n            this.setQuery(mutationId, function () {\n              return {\n                document: mutation\n              };\n            });\n            variables = this.getVariables(mutation, variables);\n            if (!this.transform(mutation).hasClientExports) return [3, 2];\n            return [4, this.localState.addExportedVariables(mutation, variables, context)];\n\n          case 1:\n            variables = _f.sent();\n            _f.label = 2;\n\n          case 2:\n            generateUpdateQueriesInfo = function () {\n              var ret = {};\n\n              if (updateQueriesByName) {\n                _this.queries.forEach(function (_a, queryId) {\n                  var observableQuery = _a.observableQuery;\n\n                  if (observableQuery) {\n                    var queryName = observableQuery.queryName;\n\n                    if (queryName && hasOwnProperty.call(updateQueriesByName, queryName)) {\n                      ret[queryId] = {\n                        updater: updateQueriesByName[queryName],\n                        query: _this.queryStore.get(queryId)\n                      };\n                    }\n                  }\n                });\n              }\n\n              return ret;\n            };\n\n            this.mutationStore.initMutation(mutationId, mutation, variables);\n            this.dataStore.markMutationInit({\n              mutationId: mutationId,\n              document: mutation,\n              variables: variables,\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n              optimisticResponse: optimisticResponse\n            });\n            this.broadcastQueries();\n            self = this;\n            return [2, new Promise(function (resolve, reject) {\n              var storeResult;\n              var error;\n              self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: optimisticResponse\n              }), variables, false).subscribe({\n                next: function (result) {\n                  if (graphQLResultHasError(result) && errorPolicy === 'none') {\n                    error = new ApolloError({\n                      graphQLErrors: result.errors\n                    });\n                    return;\n                  }\n\n                  self.mutationStore.markMutationResult(mutationId);\n\n                  if (fetchPolicy !== 'no-cache') {\n                    self.dataStore.markMutationResult({\n                      mutationId: mutationId,\n                      result: result,\n                      document: mutation,\n                      variables: variables,\n                      updateQueries: generateUpdateQueriesInfo(),\n                      update: updateWithProxyFn\n                    });\n                  }\n\n                  storeResult = result;\n                },\n                error: function (err) {\n                  self.mutationStore.markMutationError(mutationId, err);\n                  self.dataStore.markMutationComplete({\n                    mutationId: mutationId,\n                    optimisticResponse: optimisticResponse\n                  });\n                  self.broadcastQueries();\n                  self.setQuery(mutationId, function () {\n                    return {\n                      document: null\n                    };\n                  });\n                  reject(new ApolloError({\n                    networkError: err\n                  }));\n                },\n                complete: function () {\n                  if (error) {\n                    self.mutationStore.markMutationError(mutationId, error);\n                  }\n\n                  self.dataStore.markMutationComplete({\n                    mutationId: mutationId,\n                    optimisticResponse: optimisticResponse\n                  });\n                  self.broadcastQueries();\n\n                  if (error) {\n                    reject(error);\n                    return;\n                  }\n\n                  if (typeof refetchQueries === 'function') {\n                    refetchQueries = refetchQueries(storeResult);\n                  }\n\n                  var refetchQueryPromises = [];\n\n                  if (isNonEmptyArray(refetchQueries)) {\n                    refetchQueries.forEach(function (refetchQuery) {\n                      if (typeof refetchQuery === 'string') {\n                        self.queries.forEach(function (_a) {\n                          var observableQuery = _a.observableQuery;\n\n                          if (observableQuery && observableQuery.queryName === refetchQuery) {\n                            refetchQueryPromises.push(observableQuery.refetch());\n                          }\n                        });\n                      } else {\n                        var queryOptions = {\n                          query: refetchQuery.query,\n                          variables: refetchQuery.variables,\n                          fetchPolicy: 'network-only'\n                        };\n\n                        if (refetchQuery.context) {\n                          queryOptions.context = refetchQuery.context;\n                        }\n\n                        refetchQueryPromises.push(self.query(queryOptions));\n                      }\n                    });\n                  }\n\n                  Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {\n                    self.setQuery(mutationId, function () {\n                      return {\n                        document: null\n                      };\n                    });\n\n                    if (errorPolicy === 'ignore' && storeResult && graphQLResultHasError(storeResult)) {\n                      delete storeResult.errors;\n                    }\n\n                    resolve(storeResult);\n                  });\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  QueryManager.prototype.fetchQuery = function (queryId, options, fetchType, fetchMoreForQueryId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, metadata, _b, fetchPolicy, _c, context, query, variables, storeResult, isNetworkOnly, needToFetch, _d, complete, result, shouldFetch, requestId, cancel, networkResult;\n\n      var _this = this;\n\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            _a = options.metadata, metadata = _a === void 0 ? null : _a, _b = options.fetchPolicy, fetchPolicy = _b === void 0 ? 'cache-first' : _b, _c = options.context, context = _c === void 0 ? {} : _c;\n            query = this.transform(options.query).document;\n            variables = this.getVariables(query, options.variables);\n            if (!this.transform(query).hasClientExports) return [3, 2];\n            return [4, this.localState.addExportedVariables(query, variables, context)];\n\n          case 1:\n            variables = _e.sent();\n            _e.label = 2;\n\n          case 2:\n            options = __assign(__assign({}, options), {\n              variables: variables\n            });\n            isNetworkOnly = fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n            needToFetch = isNetworkOnly;\n\n            if (!isNetworkOnly) {\n              _d = this.dataStore.getCache().diff({\n                query: query,\n                variables: variables,\n                returnPartialData: true,\n                optimistic: false\n              }), complete = _d.complete, result = _d.result;\n              needToFetch = !complete || fetchPolicy === 'cache-and-network';\n              storeResult = result;\n            }\n\n            shouldFetch = needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n            if (hasDirectives(['live'], query)) shouldFetch = true;\n            requestId = this.idCounter++;\n            cancel = fetchPolicy !== 'no-cache' ? this.updateQueryWatch(queryId, query, options) : undefined;\n            this.setQuery(queryId, function () {\n              return {\n                document: query,\n                lastRequestId: requestId,\n                invalidated: true,\n                cancel: cancel\n              };\n            });\n            this.invalidate(fetchMoreForQueryId);\n            this.queryStore.initQuery({\n              queryId: queryId,\n              document: query,\n              storePreviousVariables: shouldFetch,\n              variables: variables,\n              isPoll: fetchType === FetchType.poll,\n              isRefetch: fetchType === FetchType.refetch,\n              metadata: metadata,\n              fetchMoreForQueryId: fetchMoreForQueryId\n            });\n            this.broadcastQueries();\n\n            if (shouldFetch) {\n              networkResult = this.fetchRequest({\n                requestId: requestId,\n                queryId: queryId,\n                document: query,\n                options: options,\n                fetchMoreForQueryId: fetchMoreForQueryId\n              }).catch(function (error) {\n                if (isApolloError(error)) {\n                  throw error;\n                } else {\n                  if (requestId >= _this.getQuery(queryId).lastRequestId) {\n                    _this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n\n                    _this.invalidate(queryId);\n\n                    _this.invalidate(fetchMoreForQueryId);\n\n                    _this.broadcastQueries();\n                  }\n\n                  throw new ApolloError({\n                    networkError: error\n                  });\n                }\n              });\n\n              if (fetchPolicy !== 'cache-and-network') {\n                return [2, networkResult];\n              }\n\n              networkResult.catch(function () {});\n            }\n\n            this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n            this.invalidate(queryId);\n            this.invalidate(fetchMoreForQueryId);\n\n            if (this.transform(query).hasForcedResolvers) {\n              return [2, this.localState.runResolvers({\n                document: query,\n                remoteResult: {\n                  data: storeResult\n                },\n                context: context,\n                variables: variables,\n                onlyRunForcedResolvers: true\n              }).then(function (result) {\n                _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);\n\n                _this.broadcastQueries();\n\n                return result;\n              })];\n            }\n\n            this.broadcastQueries();\n            return [2, {\n              data: storeResult\n            }];\n        }\n      });\n    });\n  };\n\n  QueryManager.prototype.markQueryResult = function (queryId, result, _a, fetchMoreForQueryId) {\n    var fetchPolicy = _a.fetchPolicy,\n        variables = _a.variables,\n        errorPolicy = _a.errorPolicy;\n\n    if (fetchPolicy === 'no-cache') {\n      this.setQuery(queryId, function () {\n        return {\n          newData: {\n            result: result.data,\n            complete: true\n          }\n        };\n      });\n    } else {\n      this.dataStore.markQueryResult(result, this.getQuery(queryId).document, variables, fetchMoreForQueryId, errorPolicy === 'ignore' || errorPolicy === 'all');\n    }\n  };\n\n  QueryManager.prototype.queryListenerForObserver = function (queryId, options, observer) {\n    var _this = this;\n\n    function invoke(method, argument) {\n      if (observer[method]) {\n        try {\n          observer[method](argument);\n        } catch (e) {\n          process.env.NODE_ENV === \"production\" || invariant.error(e);\n        }\n      } else if (method === 'error') {\n        process.env.NODE_ENV === \"production\" || invariant.error(argument);\n      }\n    }\n\n    return function (queryStoreValue, newData) {\n      _this.invalidate(queryId, false);\n\n      if (!queryStoreValue) return;\n\n      var _a = _this.getQuery(queryId),\n          observableQuery = _a.observableQuery,\n          document = _a.document;\n\n      var fetchPolicy = observableQuery ? observableQuery.options.fetchPolicy : options.fetchPolicy;\n      if (fetchPolicy === 'standby') return;\n      var loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n      var lastResult = observableQuery && observableQuery.getLastResult();\n      var networkStatusChanged = !!(lastResult && lastResult.networkStatus !== queryStoreValue.networkStatus);\n      var shouldNotifyIfLoading = options.returnPartialData || !newData && queryStoreValue.previousVariables || networkStatusChanged && options.notifyOnNetworkStatusChange || fetchPolicy === 'cache-only' || fetchPolicy === 'cache-and-network';\n\n      if (loading && !shouldNotifyIfLoading) {\n        return;\n      }\n\n      var hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n      var errorPolicy = observableQuery && observableQuery.options.errorPolicy || options.errorPolicy || 'none';\n\n      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n        return invoke('error', new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError\n        }));\n      }\n\n      try {\n        var data = void 0;\n        var isMissing = void 0;\n\n        if (newData) {\n          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n            _this.setQuery(queryId, function () {\n              return {\n                newData: null\n              };\n            });\n          }\n\n          data = newData.result;\n          isMissing = !newData.complete;\n        } else {\n          var lastError = observableQuery && observableQuery.getLastError();\n          var errorStatusChanged = errorPolicy !== 'none' && (lastError && lastError.graphQLErrors) !== queryStoreValue.graphQLErrors;\n\n          if (lastResult && lastResult.data && !errorStatusChanged) {\n            data = lastResult.data;\n            isMissing = false;\n          } else {\n            var diffResult = _this.dataStore.getCache().diff({\n              query: document,\n              variables: queryStoreValue.previousVariables || queryStoreValue.variables,\n              returnPartialData: true,\n              optimistic: true\n            });\n\n            data = diffResult.result;\n            isMissing = !diffResult.complete;\n          }\n        }\n\n        var stale = isMissing && !(options.returnPartialData || fetchPolicy === 'cache-only');\n        var resultFromStore = {\n          data: stale ? lastResult && lastResult.data : data,\n          loading: loading,\n          networkStatus: queryStoreValue.networkStatus,\n          stale: stale\n        };\n\n        if (errorPolicy === 'all' && hasGraphQLErrors) {\n          resultFromStore.errors = queryStoreValue.graphQLErrors;\n        }\n\n        invoke('next', resultFromStore);\n      } catch (networkError) {\n        invoke('error', new ApolloError({\n          networkError: networkError\n        }));\n      }\n    };\n  };\n\n  QueryManager.prototype.transform = function (document) {\n    var transformCache = this.transformCache;\n\n    if (!transformCache.has(document)) {\n      var cache = this.dataStore.getCache();\n      var transformed = cache.transformDocument(document);\n      var forLink = removeConnectionDirectiveFromDocument(cache.transformForLink(transformed));\n      var clientQuery = this.localState.clientQuery(transformed);\n      var serverQuery = this.localState.serverQuery(forLink);\n      var cacheEntry_1 = {\n        document: transformed,\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery: clientQuery,\n        serverQuery: serverQuery,\n        defaultVars: getDefaultValues(getOperationDefinition(transformed))\n      };\n\n      var add = function (doc) {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry_1);\n        }\n      };\n\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document);\n  };\n\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.transform(document).defaultVars), variables);\n  };\n\n  QueryManager.prototype.watchQuery = function (options, shouldSubscribe) {\n    if (shouldSubscribe === void 0) {\n      shouldSubscribe = true;\n    }\n\n    process.env.NODE_ENV === \"production\" ? invariant(options.fetchPolicy !== 'standby', 11) : invariant(options.fetchPolicy !== 'standby', 'client.watchQuery cannot be called with fetchPolicy set to \"standby\"');\n    options.variables = this.getVariables(options.query, options.variables);\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    var transformedOptions = __assign({}, options);\n\n    return new ObservableQuery({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe\n    });\n  };\n\n  QueryManager.prototype.query = function (options) {\n    var _this = this;\n\n    process.env.NODE_ENV === \"production\" ? invariant(options.query, 12) : invariant(options.query, 'query option is required. You must specify your GraphQL document ' + 'in the query option.');\n    process.env.NODE_ENV === \"production\" ? invariant(options.query.kind === 'Document', 13) : invariant(options.query.kind === 'Document', 'You must wrap the query string in a \"gql\" tag.');\n    process.env.NODE_ENV === \"production\" ? invariant(!options.returnPartialData, 14) : invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.');\n    process.env.NODE_ENV === \"production\" ? invariant(!options.pollInterval, 15) : invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.');\n    return new Promise(function (resolve, reject) {\n      var watchedQuery = _this.watchQuery(options, false);\n\n      _this.fetchQueryRejectFns.set(\"query:\" + watchedQuery.queryId, reject);\n\n      watchedQuery.result().then(resolve, reject).then(function () {\n        return _this.fetchQueryRejectFns.delete(\"query:\" + watchedQuery.queryId);\n      });\n    });\n  };\n\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.idCounter++);\n  };\n\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(queryId);\n  };\n\n  QueryManager.prototype.addQueryListener = function (queryId, listener) {\n    this.setQuery(queryId, function (_a) {\n      var listeners = _a.listeners;\n      listeners.add(listener);\n      return {\n        invalidated: false\n      };\n    });\n  };\n\n  QueryManager.prototype.updateQueryWatch = function (queryId, document, options) {\n    var _this = this;\n\n    var cancel = this.getQuery(queryId).cancel;\n    if (cancel) cancel();\n\n    var previousResult = function () {\n      var previousResult = null;\n\n      var observableQuery = _this.getQuery(queryId).observableQuery;\n\n      if (observableQuery) {\n        var lastResult = observableQuery.getLastResult();\n\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n\n    return this.dataStore.getCache().watch({\n      query: document,\n      variables: options.variables,\n      optimistic: true,\n      previousResult: previousResult,\n      callback: function (newData) {\n        _this.setQuery(queryId, function () {\n          return {\n            invalidated: true,\n            newData: newData\n          };\n        });\n      }\n    });\n  };\n\n  QueryManager.prototype.addObservableQuery = function (queryId, observableQuery) {\n    this.setQuery(queryId, function () {\n      return {\n        observableQuery: observableQuery\n      };\n    });\n  };\n\n  QueryManager.prototype.removeObservableQuery = function (queryId) {\n    var cancel = this.getQuery(queryId).cancel;\n    this.setQuery(queryId, function () {\n      return {\n        observableQuery: null\n      };\n    });\n    if (cancel) cancel();\n  };\n\n  QueryManager.prototype.clearStore = function () {\n    this.fetchQueryRejectFns.forEach(function (reject) {\n      reject(process.env.NODE_ENV === \"production\" ? new InvariantError(16) : new InvariantError('Store reset while query was in flight (not completed in link chain)'));\n    });\n    var resetIds = [];\n    this.queries.forEach(function (_a, queryId) {\n      var observableQuery = _a.observableQuery;\n      if (observableQuery) resetIds.push(queryId);\n    });\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n    return this.dataStore.reset();\n  };\n\n  QueryManager.prototype.resetStore = function () {\n    var _this = this;\n\n    return this.clearStore().then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n\n    var observableQueryPromises = [];\n    this.queries.forEach(function (_a, queryId) {\n      var observableQuery = _a.observableQuery;\n\n      if (observableQuery) {\n        var fetchPolicy = observableQuery.options.fetchPolicy;\n        observableQuery.resetLastResults();\n\n        if (fetchPolicy !== 'cache-only' && (includeStandby || fetchPolicy !== 'standby')) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        _this.setQuery(queryId, function () {\n          return {\n            newData: null\n          };\n        });\n\n        _this.invalidate(queryId);\n      }\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n\n  QueryManager.prototype.observeQuery = function (queryId, options, observer) {\n    this.addQueryListener(queryId, this.queryListenerForObserver(queryId, options, observer));\n    return this.fetchQuery(queryId, options);\n  };\n\n  QueryManager.prototype.startQuery = function (queryId, options, listener) {\n    process.env.NODE_ENV === \"production\" || invariant.warn(\"The QueryManager.startQuery method has been deprecated\");\n    this.addQueryListener(queryId, listener);\n    this.fetchQuery(queryId, options).catch(function () {\n      return undefined;\n    });\n    return queryId;\n  };\n\n  QueryManager.prototype.startGraphQLSubscription = function (_a) {\n    var _this = this;\n\n    var query = _a.query,\n        fetchPolicy = _a.fetchPolicy,\n        variables = _a.variables;\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, {}, variables, false).map(function (result) {\n        if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n          _this.dataStore.markSubscriptionResult(result, query, variables);\n\n          _this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors\n          });\n        }\n\n        return result;\n      });\n    };\n\n    if (this.transform(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n\n    return makeObservable(variables);\n  };\n\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n\n  QueryManager.prototype.removeQuery = function (queryId) {\n    this.fetchQueryRejectFns.delete(\"query:\" + queryId);\n    this.fetchQueryRejectFns.delete(\"fetchRequest:\" + queryId);\n    this.getQuery(queryId).subscriptions.forEach(function (x) {\n      return x.unsubscribe();\n    });\n    this.queries.delete(queryId);\n  };\n\n  QueryManager.prototype.getCurrentQueryResult = function (observableQuery, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = true;\n    }\n\n    var _a = observableQuery.options,\n        variables = _a.variables,\n        query = _a.query,\n        fetchPolicy = _a.fetchPolicy,\n        returnPartialData = _a.returnPartialData;\n    var lastResult = observableQuery.getLastResult();\n    var newData = this.getQuery(observableQuery.queryId).newData;\n\n    if (newData && newData.complete) {\n      return {\n        data: newData.result,\n        partial: false\n      };\n    }\n\n    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return {\n        data: undefined,\n        partial: false\n      };\n    }\n\n    var _b = this.dataStore.getCache().diff({\n      query: query,\n      variables: variables,\n      previousResult: lastResult ? lastResult.data : undefined,\n      returnPartialData: true,\n      optimistic: optimistic\n    }),\n        result = _b.result,\n        complete = _b.complete;\n\n    return {\n      data: complete || returnPartialData ? result : void 0,\n      partial: !complete\n    };\n  };\n\n  QueryManager.prototype.getQueryWithPreviousResult = function (queryIdOrObservable) {\n    var observableQuery;\n\n    if (typeof queryIdOrObservable === 'string') {\n      var foundObserveableQuery = this.getQuery(queryIdOrObservable).observableQuery;\n      process.env.NODE_ENV === \"production\" ? invariant(foundObserveableQuery, 17) : invariant(foundObserveableQuery, \"ObservableQuery with this id doesn't exist: \" + queryIdOrObservable);\n      observableQuery = foundObserveableQuery;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    var _a = observableQuery.options,\n        variables = _a.variables,\n        query = _a.query;\n    return {\n      previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n      variables: variables,\n      document: query\n    };\n  };\n\n  QueryManager.prototype.broadcastQueries = function () {\n    var _this = this;\n\n    this.onBroadcast();\n    this.queries.forEach(function (info, id) {\n      if (info.invalidated) {\n        info.listeners.forEach(function (listener) {\n          if (listener) {\n            listener(_this.queryStore.get(id), info.newData);\n          }\n        });\n      }\n    });\n  };\n\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {\n    var _this = this;\n\n    if (deduplication === void 0) {\n      deduplication = this.queryDeduplication;\n    }\n\n    var observable;\n    var serverQuery = this.transform(query).serverQuery;\n\n    if (serverQuery) {\n      var _a = this,\n          inFlightLinkObservables_1 = _a.inFlightLinkObservables,\n          link = _a.link;\n\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        }))\n      };\n      context = operation.context;\n\n      if (deduplication) {\n        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();\n        inFlightLinkObservables_1.set(serverQuery, byVariables_1);\n        var varJson_1 = JSON.stringify(variables);\n        observable = byVariables_1.get(varJson_1);\n\n        if (!observable) {\n          byVariables_1.set(varJson_1, observable = multiplex(execute(link, operation)));\n\n          var cleanup = function () {\n            byVariables_1.delete(varJson_1);\n            if (!byVariables_1.size) inFlightLinkObservables_1.delete(serverQuery);\n            cleanupSub_1.unsubscribe();\n          };\n\n          var cleanupSub_1 = observable.subscribe({\n            next: cleanup,\n            error: cleanup,\n            complete: cleanup\n          });\n        }\n      } else {\n        observable = multiplex(execute(link, operation));\n      }\n    } else {\n      observable = Observable.of({\n        data: {}\n      });\n      context = this.prepareContext(context);\n    }\n\n    var clientQuery = this.transform(query).clientQuery;\n\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n\n    return observable;\n  };\n\n  QueryManager.prototype.fetchRequest = function (_a) {\n    var _this = this;\n\n    var requestId = _a.requestId,\n        queryId = _a.queryId,\n        document = _a.document,\n        options = _a.options,\n        fetchMoreForQueryId = _a.fetchMoreForQueryId;\n    var variables = options.variables,\n        _b = options.errorPolicy,\n        errorPolicy = _b === void 0 ? 'none' : _b,\n        fetchPolicy = options.fetchPolicy;\n    var resultFromStore;\n    var errorsFromStore;\n    return new Promise(function (resolve, reject) {\n      var observable = _this.getObservableFromLink(document, options.context, variables);\n\n      var fqrfId = \"fetchRequest:\" + queryId;\n\n      _this.fetchQueryRejectFns.set(fqrfId, reject);\n\n      var cleanup = function () {\n        _this.fetchQueryRejectFns.delete(fqrfId);\n\n        _this.setQuery(queryId, function (_a) {\n          var subscriptions = _a.subscriptions;\n          subscriptions.delete(subscription);\n        });\n      };\n\n      var subscription = observable.map(function (result) {\n        if (requestId >= _this.getQuery(queryId).lastRequestId) {\n          _this.markQueryResult(queryId, result, options, fetchMoreForQueryId);\n\n          _this.queryStore.markQueryResult(queryId, result, fetchMoreForQueryId);\n\n          _this.invalidate(queryId);\n\n          _this.invalidate(fetchMoreForQueryId);\n\n          _this.broadcastQueries();\n        }\n\n        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n          return reject(new ApolloError({\n            graphQLErrors: result.errors\n          }));\n        }\n\n        if (errorPolicy === 'all') {\n          errorsFromStore = result.errors;\n        }\n\n        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n          resultFromStore = result.data;\n        } else {\n          var _a = _this.dataStore.getCache().diff({\n            variables: variables,\n            query: document,\n            optimistic: false,\n            returnPartialData: true\n          }),\n              result_1 = _a.result,\n              complete = _a.complete;\n\n          if (complete || options.returnPartialData) {\n            resultFromStore = result_1;\n          }\n        }\n      }).subscribe({\n        error: function (error) {\n          cleanup();\n          reject(error);\n        },\n        complete: function () {\n          cleanup();\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false\n          });\n        }\n      });\n\n      _this.setQuery(queryId, function (_a) {\n        var subscriptions = _a.subscriptions;\n        subscriptions.add(subscription);\n      });\n    });\n  };\n\n  QueryManager.prototype.getQuery = function (queryId) {\n    return this.queries.get(queryId) || {\n      listeners: new Set(),\n      invalidated: false,\n      document: null,\n      newData: null,\n      lastRequestId: 1,\n      observableQuery: null,\n      subscriptions: new Set()\n    };\n  };\n\n  QueryManager.prototype.setQuery = function (queryId, updater) {\n    var prev = this.getQuery(queryId);\n\n    var newInfo = __assign(__assign({}, prev), updater(prev));\n\n    this.queries.set(queryId, newInfo);\n  };\n\n  QueryManager.prototype.invalidate = function (queryId, invalidated) {\n    if (invalidated === void 0) {\n      invalidated = true;\n    }\n\n    if (queryId) {\n      this.setQuery(queryId, function () {\n        return {\n          invalidated: invalidated\n        };\n      });\n    }\n  };\n\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign({}, newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n\n  QueryManager.prototype.checkInFlight = function (queryId) {\n    var query = this.queryStore.get(queryId);\n    return query && query.networkStatus !== NetworkStatus.ready && query.networkStatus !== NetworkStatus.error;\n  };\n\n  QueryManager.prototype.startPollingQuery = function (options, queryId, listener) {\n    var _this = this;\n\n    var pollInterval = options.pollInterval;\n    process.env.NODE_ENV === \"production\" ? invariant(pollInterval, 18) : invariant(pollInterval, 'Attempted to start a polling query without a polling interval.');\n\n    if (!this.ssrMode) {\n      var info = this.pollingInfoByQueryId.get(queryId);\n\n      if (!info) {\n        this.pollingInfoByQueryId.set(queryId, info = {});\n      }\n\n      info.interval = pollInterval;\n      info.options = __assign(__assign({}, options), {\n        fetchPolicy: 'network-only'\n      });\n\n      var maybeFetch_1 = function () {\n        var info = _this.pollingInfoByQueryId.get(queryId);\n\n        if (info) {\n          if (_this.checkInFlight(queryId)) {\n            poll_1();\n          } else {\n            _this.fetchQuery(queryId, info.options, FetchType.poll).then(poll_1, poll_1);\n          }\n        }\n      };\n\n      var poll_1 = function () {\n        var info = _this.pollingInfoByQueryId.get(queryId);\n\n        if (info) {\n          clearTimeout(info.timeout);\n          info.timeout = setTimeout(maybeFetch_1, info.interval);\n        }\n      };\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      poll_1();\n    }\n\n    return queryId;\n  };\n\n  QueryManager.prototype.stopPollingQuery = function (queryId) {\n    this.pollingInfoByQueryId.delete(queryId);\n  };\n\n  return QueryManager;\n}();\n\nvar DataStore = function () {\n  function DataStore(initialCache) {\n    this.cache = initialCache;\n  }\n\n  DataStore.prototype.getCache = function () {\n    return this.cache;\n  };\n\n  DataStore.prototype.markQueryResult = function (result, document, variables, fetchMoreForQueryId, ignoreErrors) {\n    if (ignoreErrors === void 0) {\n      ignoreErrors = false;\n    }\n\n    var writeWithErrors = !graphQLResultHasError(result);\n\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables\n      });\n    }\n  };\n\n  DataStore.prototype.markSubscriptionResult = function (result, document, variables) {\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables\n      });\n    }\n  };\n\n  DataStore.prototype.markMutationInit = function (mutation) {\n    var _this = this;\n\n    if (mutation.optimisticResponse) {\n      var optimistic_1;\n\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic_1 = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic_1 = mutation.optimisticResponse;\n      }\n\n      this.cache.recordOptimisticTransaction(function (c) {\n        var orig = _this.cache;\n        _this.cache = c;\n\n        try {\n          _this.markMutationResult({\n            mutationId: mutation.mutationId,\n            result: {\n              data: optimistic_1\n            },\n            document: mutation.document,\n            variables: mutation.variables,\n            updateQueries: mutation.updateQueries,\n            update: mutation.update\n          });\n        } finally {\n          _this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  };\n\n  DataStore.prototype.markMutationResult = function (mutation) {\n    var _this = this;\n\n    if (!graphQLResultHasError(mutation.result)) {\n      var cacheWrites_1 = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables\n      }];\n      var updateQueries_1 = mutation.updateQueries;\n\n      if (updateQueries_1) {\n        Object.keys(updateQueries_1).forEach(function (id) {\n          var _a = updateQueries_1[id],\n              query = _a.query,\n              updater = _a.updater;\n\n          var _b = _this.cache.diff({\n            query: query.document,\n            variables: query.variables,\n            returnPartialData: true,\n            optimistic: false\n          }),\n              currentQueryResult = _b.result,\n              complete = _b.complete;\n\n          if (complete) {\n            var nextQueryResult = tryFunctionOrLogError(function () {\n              return updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables\n              });\n            });\n\n            if (nextQueryResult) {\n              cacheWrites_1.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables\n              });\n            }\n          }\n        });\n      }\n\n      this.cache.performTransaction(function (c) {\n        cacheWrites_1.forEach(function (write) {\n          return c.write(write);\n        });\n        var update = mutation.update;\n\n        if (update) {\n          tryFunctionOrLogError(function () {\n            return update(c, mutation.result);\n          });\n        }\n      });\n    }\n  };\n\n  DataStore.prototype.markMutationComplete = function (_a) {\n    var mutationId = _a.mutationId,\n        optimisticResponse = _a.optimisticResponse;\n\n    if (optimisticResponse) {\n      this.cache.removeOptimistic(mutationId);\n    }\n  };\n\n  DataStore.prototype.markUpdateQueryResult = function (document, variables, newResult) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables: variables,\n      query: document\n    });\n  };\n\n  DataStore.prototype.reset = function () {\n    return this.cache.reset();\n  };\n\n  return DataStore;\n}();\n\nvar version = \"2.6.10\";\nvar hasSuggestedDevtools = false;\n\nvar ApolloClient = function () {\n  function ApolloClient(options) {\n    var _this = this;\n\n    this.defaultOptions = {};\n    this.resetStoreCallbacks = [];\n    this.clearStoreCallbacks = [];\n    var cache = options.cache,\n        _a = options.ssrMode,\n        ssrMode = _a === void 0 ? false : _a,\n        _b = options.ssrForceFetchDelay,\n        ssrForceFetchDelay = _b === void 0 ? 0 : _b,\n        connectToDevTools = options.connectToDevTools,\n        _c = options.queryDeduplication,\n        queryDeduplication = _c === void 0 ? true : _c,\n        defaultOptions = options.defaultOptions,\n        _d = options.assumeImmutableResults,\n        assumeImmutableResults = _d === void 0 ? false : _d,\n        resolvers = options.resolvers,\n        typeDefs = options.typeDefs,\n        fragmentMatcher = options.fragmentMatcher,\n        clientAwarenessName = options.name,\n        clientAwarenessVersion = options.version;\n    var link = options.link;\n\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError(4) : new InvariantError(\"In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\\n\" + \"These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\\n\" + \"For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup\");\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(function () {\n        return _this.disableNetworkFetches = false;\n      }, ssrForceFetchDelay);\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n    var defaultConnectToDevTools = process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && !window.__APOLLO_CLIENT__;\n\n    if (typeof connectToDevTools === 'undefined' ? defaultConnectToDevTools : connectToDevTools && typeof window !== 'undefined') {\n      window.__APOLLO_CLIENT__ = this;\n    }\n\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n\n      if (typeof window !== 'undefined' && window.document && window.top === window.self) {\n        if (typeof window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n          if (window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf('Chrome') > -1) {\n            console.debug('Download the Apollo DevTools ' + 'for a better development experience: ' + 'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm');\n          }\n        }\n      }\n    }\n\n    this.version = version;\n    this.localState = new LocalState({\n      cache: cache,\n      client: this,\n      resolvers: resolvers,\n      fragmentMatcher: fragmentMatcher\n    });\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication: queryDeduplication,\n      ssrMode: ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName,\n        version: clientAwarenessVersion\n      },\n      localState: this.localState,\n      assumeImmutableResults: assumeImmutableResults,\n      onBroadcast: function () {\n        if (_this.devToolsHookCb) {\n          _this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: _this.queryManager.queryStore.getStore(),\n              mutations: _this.queryManager.mutationStore.getStore()\n            },\n            dataWithOptimisticResults: _this.cache.extract(true)\n          });\n        }\n      }\n    });\n  }\n\n  ApolloClient.prototype.stop = function () {\n    this.queryManager.stop();\n  };\n\n  ApolloClient.prototype.watchQuery = function (options) {\n    if (this.defaultOptions.watchQuery) {\n      options = __assign(__assign({}, this.defaultOptions.watchQuery), options);\n    }\n\n    if (this.disableNetworkFetches && (options.fetchPolicy === 'network-only' || options.fetchPolicy === 'cache-and-network')) {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: 'cache-first'\n      });\n    }\n\n    return this.queryManager.watchQuery(options);\n  };\n\n  ApolloClient.prototype.query = function (options) {\n    if (this.defaultOptions.query) {\n      options = __assign(__assign({}, this.defaultOptions.query), options);\n    }\n\n    process.env.NODE_ENV === \"production\" ? invariant(options.fetchPolicy !== 'cache-and-network', 5) : invariant(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' + 'client.query can only return a single result. Please use client.watchQuery ' + 'to receive multiple results from the cache and the network, or consider ' + 'using a different fetchPolicy, such as cache-first or network-only.');\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: 'cache-first'\n      });\n    }\n\n    return this.queryManager.query(options);\n  };\n\n  ApolloClient.prototype.mutate = function (options) {\n    if (this.defaultOptions.mutate) {\n      options = __assign(__assign({}, this.defaultOptions.mutate), options);\n    }\n\n    return this.queryManager.mutate(options);\n  };\n\n  ApolloClient.prototype.subscribe = function (options) {\n    return this.queryManager.startGraphQLSubscription(options);\n  };\n\n  ApolloClient.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n\n    return this.cache.readQuery(options, optimistic);\n  };\n\n  ApolloClient.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n\n    return this.cache.readFragment(options, optimistic);\n  };\n\n  ApolloClient.prototype.writeQuery = function (options) {\n    var result = this.cache.writeQuery(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  };\n\n  ApolloClient.prototype.writeFragment = function (options) {\n    var result = this.cache.writeFragment(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  };\n\n  ApolloClient.prototype.writeData = function (options) {\n    var result = this.cache.writeData(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  };\n\n  ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n    this.devToolsHookCb = cb;\n  };\n\n  ApolloClient.prototype.__requestRaw = function (payload) {\n    return execute(this.link, payload);\n  };\n\n  ApolloClient.prototype.initQueryManager = function () {\n    process.env.NODE_ENV === \"production\" || invariant.warn('Calling the initQueryManager method is no longer necessary, ' + 'and it will be removed from ApolloClient in version 3.0.');\n    return this.queryManager;\n  };\n\n  ApolloClient.prototype.resetStore = function () {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore();\n    }).then(function () {\n      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n\n  ApolloClient.prototype.clearStore = function () {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore();\n    }).then(function () {\n      return Promise.all(_this.clearStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    });\n  };\n\n  ApolloClient.prototype.onResetStore = function (cb) {\n    var _this = this;\n\n    this.resetStoreCallbacks.push(cb);\n    return function () {\n      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n\n  ApolloClient.prototype.onClearStore = function (cb) {\n    var _this = this;\n\n    this.clearStoreCallbacks.push(cb);\n    return function () {\n      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n\n  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  };\n\n  ApolloClient.prototype.extract = function (optimistic) {\n    return this.cache.extract(optimistic);\n  };\n\n  ApolloClient.prototype.restore = function (serializedState) {\n    return this.cache.restore(serializedState);\n  };\n\n  ApolloClient.prototype.addResolvers = function (resolvers) {\n    this.localState.addResolvers(resolvers);\n  };\n\n  ApolloClient.prototype.setResolvers = function (resolvers) {\n    this.localState.setResolvers(resolvers);\n  };\n\n  ApolloClient.prototype.getResolvers = function () {\n    return this.localState.getResolvers();\n  };\n\n  ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  };\n\n  return ApolloClient;\n}();\n\nexport default ApolloClient;\nexport { ApolloClient, ApolloError, FetchType, NetworkStatus, ObservableQuery, isApolloError };","map":{"version":3,"mappings":";;;;;;IAGYA;;AAAZ,WAAYA,aAAZ,EAAyB;EAMvBA;EAMAA;EAMAA;EAMAA;EAOAA;EAKAA;EAKAA;AACD,CA1CD,EAAYA,aAAa,KAAbA,aAAa,MAAzB;;AAgDA,SAAgBC,wBAAhB,CACEC,aADF,EAC8B;EAE5B,OAAOA,aAAa,GAAG,CAAvB;AACD;;AC7CD;EAAmCC;;EAAnC;;EAQC;;EAPQC,qBAACC,YAAD,IAAP;IACE,OAAO,IAAP;EACD,CAFM;;EAIAD,qBAAC,cAAD,IAAP;IACE,OAAO,IAAP;EACD,CAFM;;EAGT;AARA,EAAmCE,YAAnC;;SCVgBC,gBAAmBC,OAAoB;EACrD,OAAOC,KAAK,CAACC,OAAN,CAAcF,KAAd,KAAwBA,KAAK,CAACG,MAAN,GAAe,CAA9C;AACD;;SCCeC,cAAcC,KAAU;EACtC,OAAOA,GAAG,CAACC,cAAJ,CAAmB,eAAnB,CAAP;AACD;;AAMD,IAAMC,oBAAoB,GAAG,UAACF,GAAD,EAAiB;EAC5C,IAAIG,OAAO,GAAG,EAAd;;EAEA,IAAIT,eAAe,CAACM,GAAG,CAACI,aAAL,CAAnB,EAAwC;IACtCJ,GAAG,CAACI,aAAJ,CAAkBC,OAAlB,CAA0B,UAACC,YAAD,EAA2B;MACnD,IAAMC,YAAY,GAAGD,YAAY,GAC7BA,YAAY,CAACH,OADgB,GAE7B,0BAFJ;MAGAA,OAAO,IAAI,oBAAkBI,YAAlB,GAA8B,IAAzC;IACD,CALD;EAMD;;EAED,IAAIP,GAAG,CAACQ,YAAR,EAAsB;IACpBL,OAAO,IAAI,oBAAoBH,GAAG,CAACQ,YAAJ,CAAiBL,OAArC,GAA+C,IAA1D;EACD;;EAGDA,OAAO,GAAGA,OAAO,CAACM,OAAR,CAAgB,KAAhB,EAAuB,EAAvB,CAAV;EACA,OAAON,OAAP;AACD,CAnBD;;AAqBA;EAAiCb;;EAa/B,qBAAYoB,EAAZ,EAUC;QATCN;QACAI;QACAD;QACAI;;IAJF,YAWEC,kBAAML,YAAN,KAAmB,IAXrB;;IAYEM,KAAI,CAACT,aAAL,GAAqBA,aAAa,IAAI,EAAtC;IACAS,KAAI,CAACL,YAAL,GAAoBA,YAAY,IAAI,IAApC;;IAEA,IAAI,CAACD,YAAL,EAAmB;MACjBM,KAAI,CAACV,OAAL,GAAeD,oBAAoB,CAACW,KAAD,CAAnC;IACD,CAFD,MAEO;MACLA,KAAI,CAACV,OAAL,GAAeI,YAAf;IACD;;IAEDM,KAAI,CAACF,SAAL,GAAiBA,SAAjB;IAICE,KAAY,CAACC,SAAb,GAAyBC,WAAW,CAACC,SAArC;;EACF;;EACH;AAxCA,EAAiCC,KAAjC;;ICHYC;;AAAZ,WAAYA,SAAZ,EAAqB;EACnBA;EACAA;EACAA;AACD,CAJD,EAAYA,SAAS,KAATA,SAAS,MAArB;;ACiCO,IAAMC,QAAQ,GAAG,UACtBC,UADsB,EAEtBC,MAFsB,EAEM;EAA5B;IAAAA;EAA4B;;EACzB,iBAAU,KACbD,UAAU,CAACZ,YAAX,IACCa,MAAM,KAAK,MAAX,IAAqB3B,eAAe,CAAC0B,UAAU,CAAChB,aAAZ,CAFxB,CAAV;AAGJ,CANM;;AAQP;EAGUd;;EAoBR,yBAAYoB,EAAZ,EAQC;QAPCY;QACAC;QACAC;QAAAC;;IAHF,YASEb,kBAAM,UAACc,QAAD,EAA6C;MACjD,YAAI,CAACC,WAAL,CAAiBD,QAAjB;IAA0B,CAD5B,KAEC,IAXH;;IAPQb,kBAAY,IAAIe,GAAJ,EAAZ;IACAf,sBAAgB,IAAIe,GAAJ,EAAhB;IAoBNf,KAAI,CAACgB,UAAL,GAAkB,KAAlB;IAGAhB,KAAI,CAACU,OAAL,GAAeA,OAAf;IACAV,KAAI,CAACiB,SAAL,GAAiBP,OAAO,CAACO,SAAR,IAAsB,EAAvC;IACAjB,KAAI,CAACkB,OAAL,GAAeT,YAAY,CAACU,eAAb,EAAf;IACAnB,KAAI,CAACY,eAAL,GAAuBA,eAAvB;IAEA,IAAMQ,KAAK,GAAGC,sBAAsB,CAACX,OAAO,CAACY,KAAT,CAApC;IACAtB,KAAI,CAACuB,SAAL,GAAiBH,KAAK,IAAIA,KAAK,CAACI,IAAf,IAAuBJ,KAAK,CAACI,IAAN,CAAW1C,KAAnD;IAGAkB,KAAI,CAACS,YAAL,GAAoBA,YAApB;;EACD;;EAEMgB,mCAAP;IAAA;;IACE,OAAO,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;MACjC,IAAMf,QAAQ,GAAuC;QACnDgB,IAAI,EAAE,UAACC,MAAD,EAAiC;UACrCH,OAAO,CAACG,MAAD,CAAP;;UAYA9B,KAAI,CAAC+B,SAAL,CAAeC,MAAf,CAAsBnB,QAAtB;;UACA,IAAI,CAACb,KAAI,CAAC+B,SAAL,CAAeE,IAApB,EAA0B;YACxBjC,KAAI,CAACS,YAAL,CAAkByB,WAAlB,CAA8BlC,KAAI,CAACkB,OAAnC;UACD;;UAEDiB,UAAU,CAAC;YACTC,YAAY,CAACC,WAAb;UACD,CAFS,EAEP,CAFO,CAAV;QAGD,CAtBkD;QAuBnDC,KAAK,EAAEV;MAvB4C,CAArD;;MAyBA,IAAMQ,YAAY,GAAGpC,KAAI,CAACuC,SAAL,CAAe1B,QAAf,CAArB;IACD,CA3BM,CAAP;EA4BD,CA7BM;;EAiCAY,0CAAP;IACE,IAAMK,MAAM,GAAG,KAAKU,gBAAL,EAAf;;IACA,IAAIV,MAAM,CAACW,IAAP,KAAgBC,SAApB,EAA+B;MAC7BZ,MAAM,CAACW,IAAP,GAAc,EAAd;IACD;;IACD,OAAOX,MAAP;EACD,CANM;;EAcAL,6CAAP;IACE,IAAI,KAAKT,UAAT,EAAqB;MACX;MACR,OAAO;QACLyB,IAAI,EAAE,CAAC,KAAKE,SAAN,IAAmBC,UAAnB,IAAiCA,UAAU,CAACH,IAA5C,IAAoD,KAAK,CAD1D;QAELH,KAAK,EAAE,KAAKK,SAFP;QAGLE,OAAO,EAAE,KAHJ;QAILrE,aAAa,EAAEF,aAAa,CAACgE;MAJxB,CAAP;IAMD;;IAEK;IAAA,IAAEG,cAAF;IAAA,IAAQK,oBAAR;;IACN,IAAMC,eAAe,GAAG,KAAKtC,YAAL,CAAkBuC,UAAlB,CAA6BC,GAA7B,CAAiC,KAAK/B,OAAtC,CAAxB;IACA,IAAIY,MAAJ;IAEQ;IAER,IAAMoB,oBAAoB,GACxBC,WAAW,KAAK,cAAhB,IACAA,WAAW,KAAK,UAFlB;;IAIA,IAAIJ,eAAJ,EAAqB;MACX;;MAER,IAAIzC,QAAQ,CAACyC,eAAD,EAAkB,KAAKrC,OAAL,CAAa0C,WAA/B,CAAZ,EAAyD;QACvD,OAAO;UACLX,IAAI,EAAE,KAAK,CADN;UAELI,OAAO,EAAE,KAFJ;UAGLrE,aAAa,eAHR;UAIL8D,KAAK,EAAE,IAAIpC,WAAJ,CAAgB;YACrBX,aAAa,EAAEwD,eAAe,CAACxD,aADV;YAErBI,YAAY,EAAEoD,eAAe,CAACpD;UAFT,CAAhB;QAJF,CAAP;MASD;;MAOD,IAAIoD,eAAe,CAAC9B,SAApB,EAA+B;QAC7B,KAAKP,OAAL,CAAaO,SAAb,GAAsBoC,sBACjB,KAAK3C,OAAL,CAAaO,SADI,GAEhB8B,eAAe,CAAC9B,SAFA,CAAtB;QAIA,KAAKA,SAAL,GAAiB,KAAKP,OAAL,CAAaO,SAA9B;MACD;;MAEDa,MAAM,GAAG;QACPW,IAAI,MADG;QAEPI,OAAO,EAAEtE,wBAAwB,CAACC,aAAD,CAF1B;QAGPA,aAAa;MAHN,CAAT;;MAMA,IAAIuE,eAAe,CAACxD,aAAhB,IAAiC,KAAKmB,OAAL,CAAa0C,WAAb,KAA6B,KAAlE,EAAyE;QACvEtB,MAAM,CAACwB,MAAP,GAAgBP,eAAe,CAACxD,aAAhC;MACD;IAEF,CAtCD,MAsCO;MAOL,IAAMsD,OAAO,GAAGK,oBAAoB,IACjCJ,OAAO,IAAIK,WAAW,KAAK,YAD9B;MAGArB,MAAM,GAAG;QACPW,IAAI,MADG;QAEPI,OAAO,SAFA;QAGPrE,aAAa,EAAEqE,OAAO,GAAGvE,aAAa,CAACuE,OAAjB,GAA2BvE,aAAa,CAACiF;MAHxD,CAAT;IAKD;;IAED,IAAI,CAACT,OAAL,EAAc;MACZ,KAAKU,gBAAL,CAAqBH,sBAAMvB,MAAN,GAAY;QAAE2B,KAAK,EAAE;MAAT,CAAZ,CAArB;IACD;;IAED,6BAAY3B,MAAZ,GAAkB;MAAEgB,OAAO;IAAT,CAAlB;EACD,CAjFM;;EAqFArB,sDAAP,UAAiCiC,SAAjC,EAAoE;IAC1D;IACR,OAAO,EACLC,QAAQ,IACRD,SADA,IAEAC,QAAQ,CAACnF,aAAT,KAA2BkF,SAAS,CAAClF,aAFrC,IAGAmF,QAAQ,CAACF,KAAT,KAAmBC,SAAS,CAACD,KAH7B,IAIAG,OAAO,CAACD,QAAQ,CAAClB,IAAV,EAAgBiB,SAAS,CAACjB,IAA1B,CALF,CAAP;EAOD,CATM;;EAaAhB,0CAAP;IACE,OAAO,KAAKmB,UAAZ;EACD,CAFM;;EAIAnB,yCAAP;IACE,OAAO,KAAKkB,SAAZ;EACD,CAFM;;EAIAlB,6CAAP;IACE,OAAO,KAAKmB,UAAZ;IACA,OAAO,KAAKiB,kBAAZ;IACA,OAAO,KAAKlB,SAAZ;IACA,KAAK3B,UAAL,GAAkB,KAAlB;EACD,CALM;;EAOAS,kDAAP;IACE,IAAMuB,UAAU,GAAG,KAAKvC,YAAL,CAAkBuC,UAAlB,CAA6BC,GAA7B,CAAiC,KAAK/B,OAAtC,CAAnB;;IACA,IAAI8B,UAAJ,EAAgB;MACdA,UAAU,CAACrD,YAAX,GAA0B,IAA1B;MACAqD,UAAU,CAACzD,aAAX,GAA2B,EAA3B;IACD;EACF,CANM;;EAeAkC,oCAAP,UAAeR,SAAf,EAAqC;IAC7B;;IAEN,IAAIkC,WAAW,KAAK,YAApB,EAAkC;MAChC,OAAOzB,OAAO,CAACE,MAAR,CAAekC,mKAAf,CAAP;IAGD;;IAKD,IAAIX,WAAW,KAAK,UAAhB,IACAA,WAAW,KAAK,mBADpB,EACyC;MACvCA,WAAW,GAAG,cAAd;IACD;;IAED,IAAI,CAACS,OAAO,CAAC,KAAK3C,SAAN,EAAiBA,SAAjB,CAAZ,EAAyC;MAEvC,KAAKA,SAAL,GAAcoC,sBACT,KAAKpC,SADI,GAETA,SAFS,CAAd;IAID;;IAED,IAAI,CAAC2C,OAAO,CAAC,KAAKlD,OAAL,CAAaO,SAAd,EAAyB,KAAKA,SAA9B,CAAZ,EAAsD;MAEpD,KAAKP,OAAL,CAAaO,SAAb,GAAsBoC,sBACjB,KAAK3C,OAAL,CAAaO,SADI,GAEjB,KAAKA,SAFY,CAAtB;IAID;;IAED,OAAO,KAAKR,YAAL,CAAkBsD,UAAlB,CACL,KAAK7C,OADA,EACOmC,sBACP,KAAK3C,OADE,GACK;MAAEyC,WAAW;IAAb,CADL,CADP,EAGL9C,SAAS,CAAC2D,OAHL,CAAP;EAKD,CAtCM;;EAwCAvC,sCAAP,UACEwC,gBADF,EAEuC;IAFvC;;IAKEH,wCAEEI,0CAFF,GAEEA,mJAFF;;IAKA,IAAMC,eAAe,GAAGd,sBAClBY,gBAAgB,CAAC3C,KAAjB,GAAyB2C,gBAAzB,GAAyCZ,+BACxC,KAAK3C,OADmC,GAExCuD,gBAFwC,GAExB;MACnBhD,SAAS,wBACJ,KAAKA,SADD,GAEJgD,gBAAgB,CAAChD,SAFb;IADU,CAFwB,CADvB,GAQrB;MACDkC,WAAW,EAAE;IADZ,CARqB,CAAxB;;IAYA,IAAMiB,GAAG,GAAG,KAAK3D,YAAL,CAAkBU,eAAlB,EAAZ;IAEA,OAAO,KAAKV,YAAL,CACJsD,UADI,CAEHK,GAFG,EAGHD,eAHG,EAIH9D,SAAS,CAACgE,MAJP,EAKH,KAAKnD,OALF,EAOJoD,IAPI,CAQH,2BAAe;MACbtE,KAAI,CAACuE,WAAL,CAAiB,UAACC,cAAD,EAAoB;QACnC,uBAAgB,CAACD,WAAjB,CAA6BC,cAA7B,EAA6C;UAC3CC,eAAe,EAAEA,eAAe,CAAChC,IADU;UAE3CxB,SAAS,EAAEkD,eAAe,CAAClD;QAFgB,CAA7C;MAGE,CAJJ;;MAMAjB,KAAI,CAACS,YAAL,CAAkBiE,SAAlB,CAA4BN,GAA5B;;MACA,OAAOK,eAAP;IACD,CAjBE,EAkBH,iBAAK;MACHzE,KAAI,CAACS,YAAL,CAAkBiE,SAAlB,CAA4BN,GAA5B;;MACA,MAAM9B,KAAN;IACD,CArBE,CAAP;EAuBD,CA/CM;;EAoDAb,4CAAP,UAIEf,OAJF,EAQG;IARH;;IAUE,IAAM0B,YAAY,GAAG,KAAK3B,YAAL,CAClBkE,wBADkB,CACO;MACxBrD,KAAK,EAAEZ,OAAO,CAACkE,QADS;MAExB3D,SAAS,EAAEP,OAAO,CAACO;IAFK,CADP,EAKlBsB,SALkB,CAKR;MACTV,IAAI,EAAE,UAACgD,gBAAD,EAA8C;QAC1C;;QACR,IAAIN,WAAJ,EAAiB;UACfvE,KAAI,CAACuE,WAAL,CACE,UAACO,QAAD,EAAWjF,EAAX,EAAwB;gBAAXoB;YACX,kBAAW,CAAC6D,QAAD,EAAW;cACpBD,gBAAgB,kBADI;cAEpB5D,SAAS;YAFW,CAAX,CAAX;UAGE,CALN;QAOD;MACF,CAZQ;MAaTqB,KAAK,EAAE,UAACnD,GAAD,EAAS;QACd,IAAIuB,OAAO,CAACqE,OAAZ,EAAqB;UACnBrE,OAAO,CAACqE,OAAR,CAAgB5F,GAAhB;UACA;QACD;;QACD2E,yDAAwD,sCAAxD,EAAwD3E,GAAxD;MACD;IAnBQ,CALQ,CAArB;IA2BA,KAAK6F,aAAL,CAAmBC,GAAnB,CAAuB7C,YAAvB;IAEA,OAAO;MACL,IAAIpC,KAAI,CAACgF,aAAL,CAAmBhD,MAAnB,CAA0BI,YAA1B,CAAJ,EAA6C;QAC3CA,YAAY,CAACC,WAAb;MACD;IACF,CAJD;EAKD,CA5CM;;EAgDAZ,uCAAP,UACEyD,IADF,EACyB;IAEf;IACR,KAAKxE,OAAL,GAAe2C,sBACV,KAAK3C,OADK,GAEVwE,IAFU,CAAf;;IAKA,IAAIA,IAAI,CAACC,YAAT,EAAuB;MACrB,KAAKC,YAAL,CAAkBF,IAAI,CAACC,YAAvB;IACD,CAFD,MAEO,IAAID,IAAI,CAACC,YAAL,KAAsB,CAA1B,EAA6B;MAClC,KAAKE,WAAL;IACD;;IAEO;IAER,OAAO,KAAKC,YAAL,CACL,KAAK5E,OAAL,CAAaO,SADR,EAILsE,cAAc,KAAKpC,WAAnB,KACEoC,cAAc,KAAK,YAAnB,IACAA,cAAc,KAAK,SADnB,IAEApC,WAAW,KAAK,cAHlB,CAJK,EASL+B,IAAI,CAACM,YATA,CAAP;EAWD,CA5BM;;EAyDA/D,yCAAP,UACER,SADF,EAEEwE,QAFF,EAGED,YAHF,EAGqB;IADnB;MAAAC;IAAyB;;IACzB;MAAAD;IAAmB;;IAGnB,KAAKxE,UAAL,GAAkB,KAAlB;IAEAC,SAAS,GAAGA,SAAS,IAAI,KAAKA,SAA9B;;IAEA,IAAI,CAACwE,QAAD,IAAa7B,OAAO,CAAC3C,SAAD,EAAY,KAAKA,SAAjB,CAAxB,EAAqD;MAInD,OAAO,KAAKc,SAAL,CAAeE,IAAf,IAAuBuD,YAAvB,GACH,KAAK1D,MAAL,EADG,GAEHJ,OAAO,CAACC,OAAR,EAFJ;IAGD;;IAED,KAAKV,SAAL,GAAiB,KAAKP,OAAL,CAAaO,SAAb,GAAyBA,SAA1C;;IAGA,IAAI,CAAC,KAAKc,SAAL,CAAeE,IAApB,EAA0B;MACxB,OAAOP,OAAO,CAACC,OAAR,EAAP;IACD;;IAGD,OAAO,KAAKlB,YAAL,CAAkBsD,UAAlB,CACL,KAAK7C,OADA,EAEL,KAAKR,OAFA,CAAP;EAID,CA/BM;;EAiCAe,wCAAP,UACEiE,KADF,EAIY;IAEF;;IACF;IAAA,IACJlB,kCADI;IAAA,IAEJvD,wBAFI;IAAA,IAGJ2D,sBAHI;;IAQN,IAAMlB,SAAS,GAAGiC,qBAAqB,CAAC;MACtC,YAAK,CAACnB,cAAD,EAAiB;QAAEvD,SAAS;MAAX,CAAjB,CAAL;IAAoC,CADC,CAAvC;;IAIA,IAAIyC,SAAJ,EAAe;MACbjD,YAAY,CAACmF,SAAb,CAAuBC,qBAAvB,CACEjB,QADF,EAEE3D,SAFF,EAGEyC,SAHF;MAKAjD,YAAY,CAACqF,gBAAb;IACD;EACF,CA3BM;;EA6BArE,wCAAP;IACE,KAAKhB,YAAL,CAAkBsF,gBAAlB,CAAmC,KAAK7E,OAAxC;IACA,KAAKR,OAAL,CAAayE,YAAb,GAA4BzC,SAA5B;EACD,CAHM;;EAKAjB,yCAAP,UAAoB0D,YAApB,EAAwC;IACtCa,yBAAyB,CAAC,IAAD,CAAzB;IACA,KAAKtF,OAAL,CAAayE,YAAb,GAA4BA,YAA5B;IACA,KAAK1E,YAAL,CAAkBwF,iBAAlB,CAAoC,KAAKvF,OAAzC,EAAkD,KAAKQ,OAAvD;EACD,CAJM;;EAMCO,6CAAR,UAAyBiC,SAAzB,EAA4D;IAC1D,IAAMc,cAAc,GAAG,KAAK5B,UAA5B;IACA,KAAKA,UAAL,GAAkBc,SAAlB;IACA,KAAKG,kBAAL,GAA0B,KAAKpD,YAAL,CAAkByF,sBAAlB,GACtBxC,SADsB,GAEtByC,SAAS,CAACzC,SAAD,CAFb;IAGA,OAAOc,cAAP;EACD,CAPO;;EASA/C,wCAAR,UAAoBZ,QAApB,EAAgE;IAAhE;;IAGE,IAAI;MACF,IAAIuF,WAAW,GAAIvF,QAAgB,CAACwF,aAAjB,CAA+BC,SAAlD;;MACA,IAAIF,WAAW,IAAI,CAACA,WAAW,CAAC9D,KAAhC,EAAuC;QACrC8D,WAAW,CAAC9D,KAAZ,GAAoBiE,wCAApB;MACD;IACF,CALD,CAKE,WAAM,CAAE;;IAEV,IAAMC,KAAK,GAAG,CAAC,KAAKzE,SAAL,CAAeE,IAA9B;IACA,KAAKF,SAAL,CAAekD,GAAf,CAAmBpE,QAAnB;IAGA,IAAIA,QAAQ,CAACgB,IAAT,IAAiB,KAAKe,UAA1B,EAAsC/B,QAAQ,CAACgB,IAAT,CAAc,KAAKe,UAAnB;IACtC,IAAI/B,QAAQ,CAACyB,KAAT,IAAkB,KAAKK,SAA3B,EAAsC9B,QAAQ,CAACyB,KAAT,CAAe,KAAKK,SAApB;;IAGtC,IAAI6D,KAAJ,EAAW;MACT,KAAKC,UAAL;IACD;;IAED,OAAO;MACL,IAAIzG,KAAI,CAAC+B,SAAL,CAAeC,MAAf,CAAsBnB,QAAtB,KAAmC,CAACb,KAAI,CAAC+B,SAAL,CAAeE,IAAvD,EAA6D;QAC3DjC,KAAI,CAAC0G,aAAL;MACD;IACF,CAJD;EAKD,CA3BO;;EA6BAjF,uCAAR;IAAA;;IACQ;IAAA,IAAEhB,8BAAF;IAAA,IAAgBS,oBAAhB;;IAEN,IAAI,KAAKN,eAAT,EAA0B;MACxBH,YAAY,CAACkG,kBAAb,CAAuCzF,OAAvC,EAAgD,IAAhD;IACD;;IAED,IAAI,KAAKR,OAAL,CAAayE,YAAjB,EAA+B;MAC7Ba,yBAAyB,CAAC,IAAD,CAAzB;MACAvF,YAAY,CAACwF,iBAAb,CAA+B,KAAKvF,OAApC,EAA6CQ,OAA7C;IACD;;IAED,IAAM6D,OAAO,GAAG,UAACzC,KAAD,EAAmB;MAGjCtC,KAAI,CAACwD,gBAAL,CAAqBH,sBAChBrD,KAAI,CAAC4C,UADW,GACD;QAClBU,MAAM,EAAEhB,KAAK,CAAC/C,aADI;QAElBf,aAAa,EAAEF,aAAa,CAACgE,KAFX;QAGlBO,OAAO,EAAE;MAHS,CADC,CAArB;;MAMA+D,sBAAsB,CAAC5G,KAAI,CAAC+B,SAAN,EAAiB,OAAjB,EAA0B/B,KAAI,CAAC2C,SAAL,GAAiBL,KAA3C,CAAtB;IACD,CAVD;;IAYA7B,YAAY,CAACoG,YAAb,CAAiC3F,OAAjC,EAA0C,KAAKR,OAA/C,EAAwD;MACtDmB,IAAI,EAAE,UAACC,MAAD,EAAiC;QACrC,IAAI9B,KAAI,CAAC2C,SAAL,IAAkB3C,KAAI,CAAC8G,yBAAL,CAA+BhF,MAA/B,CAAtB,EAA8D;UAC5D,IAAMiF,gBAAc,GAAG/G,KAAI,CAACwD,gBAAL,CAAsB1B,MAAtB,CAAvB;;UACM;UAAA,IAAEkF,kBAAF;UAAA,IAAS/F,wBAAT;UAAA,IAAoBgG,8BAApB;;UAQN,IAAIxG,YAAY,CAACyG,SAAb,CAAuBF,OAAvB,EAA8BG,gBAAlC,EAAoD;YAClD1G,YAAY,CAAC2G,aAAb,GAA6BC,oBAA7B,CACEL,OADF,EAEE/F,SAFF,EAGEqD,IAHF,CAGO,UAACrD,SAAD,EAAsB;cAC3B,IAAMqG,iBAAiB,GAAGtH,KAAI,CAACiB,SAA/B;cACAjB,KAAI,CAACiB,SAAL,GAAiBjB,KAAI,CAACU,OAAL,CAAaO,SAAb,GAAyBA,SAA1C;;cACA,IACE,CAACa,MAAM,CAACe,OAAR,IACAkE,gBADA,IAEAE,aAAW,KAAK,YAFhB,IAGAxG,YAAY,CAACyG,SAAb,CAAuBF,OAAvB,EAA8BO,WAH9B,IAIA,CAAC3D,OAAO,CAAC0D,iBAAD,EAAoBrG,SAApB,CALV,EAME;gBACAjB,KAAI,CAACgE,OAAL;cACD,CARD,MAQO;gBACL4C,sBAAsB,CAAC5G,KAAI,CAAC+B,SAAN,EAAiB,MAAjB,EAAyBD,MAAzB,CAAtB;cACD;YACF,CAjBD;UAkBD,CAnBD,MAmBO;YACL8E,sBAAsB,CAAC5G,KAAI,CAAC+B,SAAN,EAAiB,MAAjB,EAAyBD,MAAzB,CAAtB;UACD;QACF;MACF,CAnCqD;MAoCtDQ,KAAK,EAAEyC;IApC+C,CAAxD,EAqCGyC,KArCH,CAqCSzC,OArCT;EAsCD,CA9DO;;EAgEAtD,0CAAR;IACU;IAER,KAAKT,UAAL,GAAkB,IAAlB;IACAP,YAAY,CAACsF,gBAAb,CAA8B,KAAK7E,OAAnC;IAGA,KAAK8D,aAAL,CAAmBxF,OAAnB,CAA2B,eAAG;MAAI,UAAG,CAAC6C,WAAJ;IAAiB,CAAnD;IACA,KAAK2C,aAAL,CAAmByC,KAAnB;IAEAhH,YAAY,CAACiH,qBAAb,CAAmC,KAAKxG,OAAxC;IACAT,YAAY,CAACiE,SAAb,CAAuB,KAAKxD,OAA5B;IAEA,KAAKa,SAAL,CAAe0F,KAAf;EACD,CAdO;;EAeV;AAtmBA,EAGU/I,UAHV;;AAwmBA,SAAS6H,wCAAT,CAAkDjE,KAAlD,EAAoE;EAClEwB,yCAAyCI,SAAS,MAAT,CAAe,iBAAf,EAAe5B,aAAf,EAAeA,WAAf,CAAzC;AACD;;AAED,SAASsE,sBAAT,CACE7E,SADF,EAEE4F,MAFF,EAGEC,QAHF,EAGc;EAKZ,IAAMC,mBAAmB,GAAkB,EAA3C;EACA9F,SAAS,CAACvC,OAAV,CAAkB,eAAG;IAAI,UAAG,CAACmI,MAAD,CAAH,IAAeE,mBAAmB,CAACC,IAApB,CAAyBC,GAAzB,CAAf;EAA4C,CAArE;EACAF,mBAAmB,CAACrI,OAApB,CAA4B,eAAG;IAAI,OAACuI,GAAW,CAACJ,MAAD,CAAX,CAAoBC,QAApB,CAAD;EAA8B,CAAjE;AACD;;AAED,SAAS5B,yBAAT,CACEgC,QADF,EAC8C;EAEpC;EACRlE,4KAEqG,iBAFrG,EAEqG,mGAFrG;AAID;;ACrsBD;EAAA;IACU,aAAsD,EAAtD;EA0CT;;EAxCQmE,mCAAP;IACE,OAAO,KAAKC,KAAZ;EACD,CAFM;;EAIAD,8BAAP,UAAWE,UAAX,EAA6B;IAC3B,OAAO,KAAKD,KAAL,CAAWC,UAAX,CAAP;EACD,CAFM;;EAIAF,uCAAP,UACEE,UADF,EAEEC,QAFF,EAGEnH,SAHF,EAG+B;IAE7B,KAAKiH,KAAL,CAAWC,UAAX,IAAyB;MACvBC,QAAQ,UADe;MAEvBnH,SAAS,EAAEA,SAAS,IAAI,EAFD;MAGvB4B,OAAO,EAAE,IAHc;MAIvBP,KAAK,EAAE;IAJgB,CAAzB;EAMD,CAXM;;EAaA2F,4CAAP,UAAyBE,UAAzB,EAA6C7F,KAA7C,EAAyD;IACvD,IAAM8F,QAAQ,GAAG,KAAKF,KAAL,CAAWC,UAAX,CAAjB;;IACA,IAAIC,QAAJ,EAAc;MACZA,QAAQ,CAACvF,OAAT,GAAmB,KAAnB;MACAuF,QAAQ,CAAC9F,KAAT,GAAiBA,KAAjB;IACD;EACF,CANM;;EAQA2F,6CAAP,UAA0BE,UAA1B,EAA4C;IAC1C,IAAMC,QAAQ,GAAG,KAAKF,KAAL,CAAWC,UAAX,CAAjB;;IACA,IAAIC,QAAJ,EAAc;MACZA,QAAQ,CAACvF,OAAT,GAAmB,KAAnB;MACAuF,QAAQ,CAAC9F,KAAT,GAAiB,IAAjB;IACD;EACF,CANM;;EAQA2F,gCAAP;IACE,KAAKC,KAAL,GAAa,EAAb;EACD,CAFM;;EAGT;AAAC,CA3CD;;ACcA;EAAA;IACU,aAAgD,EAAhD;EAgKT;;EA9JQG,gCAAP;IACE,OAAO,KAAKH,KAAZ;EACD,CAFM;;EAIAG,2BAAP,UAAWnH,OAAX,EAA0B;IACxB,OAAO,KAAKgH,KAAL,CAAWhH,OAAX,CAAP;EACD,CAFM;;EAIAmH,iCAAP,UAAiB/G,KAAjB,EASC;IACC,IAAMgH,aAAa,GAAG,KAAKJ,KAAL,CAAW5G,KAAK,CAACJ,OAAjB,CAAtB;IAKA4C,YACGyE,QADH,KACG,YADH,GACGrE,4BACDoE,aAAa,CAAC1D,QAAd,KAA2BtD,KAAK,CAACsD,QADhC,IAEDhB,OAAO,CAAC0E,aAAa,CAAC1D,QAAf,EAAyBtD,KAAK,CAACsD,QAA/B,CAFN,EAGD,EAHC,CADH,GAIEV,4BAGEoE,cAAc1D,QAAd,KAAsBtD,cAHxB,IAKEsC,+CALF,EAKE,+DALF,CAJF;IAUA,IACE4E,sBADF;QAEElB;;QACAhG,gCAGAgH,aAHA;UAKE,kCAAkChH,eAAlC,GAAkC;;;;;;QAOpC9C;;;;;;;;;MAUEA,aAAa,GAAgCF,qBAA7C;;;QAEFiB,aAAa,GAAG;;;MAMdA,aAAa,8BAAb;;;SAEF2I;MACAtD,wBADA;MAEA3D,0BAFA;MAGAqG,oCAHA;MAIA3H,kBAJA;MAKAJ,eAAeA,aALf;kCAAA;MAgBAkJ;IAhBA;;QAmBA,qCAAqC,QAArC,SACEP,YAAaQ;;;GAhFZ;;;IA2FL,IAAI,CAAC,KAAKR,KAAN,IAAe,CAAC,mBAApB,EACI;IACJ,KAAKA,KAAL,CAAWhH,OAAX,EAAoBvB,YAApB,GAAoB,IAApB;IACA,KAAKuI,KAAL,CAAWhH,OAAX,EAAoB3B,aAApB,GAAoCV,mDAApC;IAKA,KACEqJ,KADF,CACShH,OADT,EACSoG,iBADT,GACS,IADT;SAEEY;;QAEA,+BAA+B,QAA/B;;;;;;IAWF,IAAI,CAAC,KAAKA,KAAN,IAAe,CAAC,mBAApB,EACI;IAKJ,KAAIA,KAAJ,CAAWhH,OAAX,EAAWvB,YAAX,GAAmC2C,KAAnC;SACE4F,6CAA8C5F;;;;;;;uBAMhCqG;QACdpI,UAAU,iBAAa,KAAQ2H,KAAR,CAAQhH,OAAR;;QACvBX,YAAU;MACVA;qCAC6B;;;;;;;;EAOjC8H;;GAAA;;YAGQ,CAAClI,UAAUyI,QAAK;QACpB5I;;4BACiBR,QAAQ;;;;;;;EAO9B;;;CAjKD;;SChBgBqJ,sBAAsBC,KAAW;EAC/C,OAAOA,GAAG,CAACC,MAAJ,CAAW,CAAX,EAAcC,WAAd,KAA8BF,GAAG,CAACG,KAAJ,CAAU,CAAV,CAArC;AACD;;ACsED;EAME,oBAAYpJ,EAAZ,EAKiC;QAJ/BqJ;QACAC;QACAC;QACAC;IAEA,KAAKH,KAAL,GAAaA,KAAb;;IAEA,IAAIC,MAAJ,EAAY;MACV,KAAKA,MAAL,GAAcA,MAAd;IACD;;IAED,IAAIC,SAAJ,EAAe;MACb,KAAKE,YAAL,CAAkBF,SAAlB;IACD;;IAED,IAAIC,eAAJ,EAAqB;MACnB,KAAKE,kBAAL,CAAwBF,eAAxB;IACD;EACF;;EAEMG,oCAAP,UAAoBJ,SAApB,EAAsD;IAAtD;;IACE,KAAKA,SAAL,GAAiB,KAAKA,SAAL,IAAkB,EAAnC;;IACA,IAAIrK,KAAK,CAACC,OAAN,CAAcoK,SAAd,CAAJ,EAA8B;MAC5BA,SAAS,CAAC5J,OAAV,CAAkB,yBAAa;QAC7BQ,KAAI,CAACoJ,SAAL,GAAiBK,SAAS,CAACzJ,KAAI,CAACoJ,SAAN,EAAiBM,aAAjB,CAA1B;MACD,CAFD;IAGD,CAJD,MAIO;MACL,KAAKN,SAAL,GAAiBK,SAAS,CAAC,KAAKL,SAAN,EAAiBA,SAAjB,CAA1B;IACD;EACF,CATM;;EAWAI,oCAAP,UAAoBJ,SAApB,EAAsD;IACpD,KAAKA,SAAL,GAAiB,EAAjB;IACA,KAAKE,YAAL,CAAkBF,SAAlB;EACD,CAHM;;EAKAI,oCAAP;IACE,OAAO,KAAKJ,SAAL,IAAkB,EAAzB;EACD,CAFM;;EAQMI,oCAAb,UAAiC3J,EAAjC,EAYC;QAXC+E;QACA+E;QACAC;QACA3I;QACAN;QAAAkJ;;;QAQA,IAAIjF,QAAJ,EAAc;UACZ,WAAO,KAAKkF,eAAL,CACLlF,QADK,EAEL+E,YAAY,CAAClH,IAFR,EAGLmH,OAHK,EAIL3I,SAJK,EAKL,KAAKoI,eALA,EAMLQ,sBANK,EAOLvF,IAPK,CAOA,uBAAW;YAAI,6BACjBqF,YADiB,GACL;cACflH,IAAI,EAAEsH,WAAW,CAACjI;YADH,CADK;UAGpB,CAVK,CAAP;QAWD;;QAED,WAAO6H,YAAP;;;EACD,CA5BY;;EA8BNH,0CAAP,UAA0BH,eAA1B,EAA0D;IACxD,KAAKA,eAAL,GAAuBA,eAAvB;EACD,CAFM;;EAIAG,0CAAP;IACE,OAAO,KAAKH,eAAZ;EACD,CAFM;;EAMAG,mCAAP,UAAmB5E,QAAnB,EAAyC;IACvC,IAAIoF,aAAa,CAAC,CAAC,QAAD,CAAD,EAAapF,QAAb,CAAjB,EAAyC;MACvC,IAAI,KAAKwE,SAAT,EAAoB;QAClB,OAAOxE,QAAP;MACD;;MACDd,+HAEE,kEAFF,GAGE,mEAHF,GAIE,qBAJF;IAMD;;IACD,OAAO,IAAP;EACD,CAbM;;EAgBA0F,mCAAP,UAAmB5E,QAAnB,EAAyC;IACvC,OAAO,KAAKwE,SAAL,GAAiBa,4BAA4B,CAACrF,QAAD,CAA7C,GAA0DA,QAAjE;EACD,CAFM;;EAIA4E,sCAAP,UAAsBI,OAAtB,EAAkC;IAAZ;MAAAA;IAAY;;IACxB;;IAER,IAAMM,UAAU,yBACXN,OADW,GACJ;MACVV,KAAK,OADK;MAGViB,WAAW,EAAE,UAACC,GAAD,EAAiD;QAC5D,IAAKlB,KAAa,CAACmB,MAAnB,EAA2B;UACzB,OAAQnB,KAAa,CAACmB,MAAd,CAAqBC,gBAArB,CAAsCF,GAAtC,CAAR;QACD,CAFD,MAEO;UACLtG,iJAEI,8DAFJ;QAID;MACF;IAZS,CADI,CAAhB;;IAgBA,OAAOoG,UAAP;EACD,CApBM;;EAyBMV,4CAAb,UACE5E,QADF,EAEE3D,SAFF,EAGE2I,OAHF,EAGc;IADZ;MAAA3I;IAAkC;;IAClC;MAAA2I;IAAY;;;;QAEZ,IAAIhF,QAAJ,EAAc;UACZ,WAAO,KAAKkF,eAAL,CACLlF,QADK,EAEL,KAAK2F,uBAAL,CAA6B3F,QAA7B,EAAuC3D,SAAvC,KAAqD,EAFhD,EAGL,KAAKuJ,cAAL,CAAoBZ,OAApB,CAHK,EAIL3I,SAJK,EAKLqD,IALK,CAKA,gBAAI;YAAI,6BACVrD,SADU,GAEVwB,IAAI,CAACgI,iBAFK;UAGb,CARK,CAAP;QASD;;QAED,wBACKxJ,SADL;;;EAGD,CApBY;;EAsBNuI,4CAAP,UAA4B5E,QAA5B,EAA6C;IAC3C,IAAI8F,cAAc,GAAG,KAArB;IACAC,KAAK,CAAC/F,QAAD,EAAW;MACdgG,SAAS,EAAE;QACTC,KAAK,YAACC,IAAD,EAAK;UACR,IAAIA,IAAI,CAACtJ,IAAL,CAAU1C,KAAV,KAAoB,QAApB,IAAgCgM,IAAI,CAACC,SAAzC,EAAoD;YAClDL,cAAc,GAAGI,IAAI,CAACC,SAAL,CAAeC,IAAf,CACf,eAAG;cACD,UAAG,CAACxJ,IAAJ,CAAS1C,KAAT,KAAmB,QAAnB,IACAmM,GAAG,CAACnM,KAAJ,CAAUoM,IAAV,KAAmB,cADnB,IAEAD,GAAG,CAACnM,KAAJ,CAAUA,KAAV,KAAoB,IAFpB;YAEwB,CAJX,CAAjB;;YAMA,IAAI4L,cAAJ,EAAoB;cAClB,OAAOS,KAAP;YACD;UACF;QACF;MAbQ;IADG,CAAX,CAAL;IAiBA,OAAOT,cAAP;EACD,CApBM;;EAuBClB,+CAAR,UACE5E,QADF,EAEE3D,SAFF,EAEiC;IAE/B,OAAO,KAAKiI,KAAL,CAAWkC,IAAX,CAAgB;MACrB9J,KAAK,EAAE+J,0BAA0B,CAACzG,QAAD,CADZ;MAErB3D,SAAS,WAFY;MAGrBqK,iBAAiB,EAAE,IAHE;MAIrBC,UAAU,EAAE;IAJS,CAAhB,EAKJzJ,MALH;EAMD,CAVO;;EAYM0H,uCAAd,UACE5E,QADF,EAEE4G,SAFF,EAGE5B,OAHF,EAIE3I,SAJF,EAKEoI,eALF,EAMEQ,sBANF,EAMyC;IAHvC;MAAAD;IAAiB;;IACjB;MAAA3I;IAA2B;;IAC3B;MAAAoI;QAAyC;MAAI,CAA7C;IAA6C;;IAC7C;MAAAQ;IAAuC;;;;;;QAEjC4B,cAAc,GAAGC,iBAAiB,CAAC9G,QAAD,CAAlC;QACA+G,SAAS,GAAGC,sBAAsB,CAAChH,QAAD,CAAlC;QACAiH,WAAW,GAAGC,iBAAiB,CAACH,SAAD,CAA/B;QAEAI,mBAAmB,GAAIN,cAA0C,CACpEO,SADG;QAGAC,oBAAoB,GAAGF,mBAAmB,GAC5ClD,qBAAqB,CAACkD,mBAAD,CADuB,GAE5C,OAFE;QAIAlM,KAAoB,IAApB,EAAEqJ,KAAK,WAAP,EAASC,MAAM,YAAf;QACA+C,WAAW,GAAgB;UAC/BL,WAAW,aADoB;UAE/BjC,OAAO,wBACFA,OADE,GACK;YACVV,KAAK,OADK;YAEVC,MAAM;UAFI,CADL,CAFwB;UAO/BlI,SAAS,WAPsB;UAQ/BoI,eAAe,iBARgB;UAS/B4C,oBAAoB,sBATW;UAU/BxB,iBAAiB,EAAE,EAVY;UAW/BZ,sBAAsB;QAXS,CAA3B;QAcN,WAAO,KAAKsC,mBAAL,CACLV,cAAc,CAACW,YADV,EAELZ,SAFK,EAGLU,WAHK,EAIL5H,IAJK,CAIA,kBAAM;UAAI,OAAC;YAChBxC,MAAM,QADU;YAEhB2I,iBAAiB,EAAEyB,WAAW,CAACzB;UAFf,CAAD;QAGf,CAPK,CAAP;;;EAQD,CA1Ca;;EA4CAjB,2CAAd,UACE4C,YADF,EAEEZ,SAFF,EAGEU,WAHF,EAG0B;;;;;;;QAEhBL,WAAW,GAAyBK,WAAW,YAA/C,EAAatC,OAAO,GAAgBsC,WAAW,QAA/C,EAAsBjL,SAAS,GAAKiL,WAAW,UAA/C;QACFG,cAAc,GAAY,CAACb,SAAD,CAA1B;;QAEAc,OAAO,GAAG,UAAOC,SAAP,EAA+B;UAAA;;;cAC7C,IAAI,CAACC,aAAa,CAACD,SAAD,EAAYtL,SAAZ,CAAlB,EAA0C;gBAExC;cACD;;cAED,IAAIwL,OAAO,CAACF,SAAD,CAAX,EAAwB;gBACtB,WAAO,KAAKG,YAAL,CAAkBH,SAAlB,EAA6Bf,SAA7B,EAAwCU,WAAxC,EAAqD5H,IAArD,CACL,uBAAW;;;kBACT,IAAI,OAAOqI,WAAP,KAAuB,WAA3B,EAAwC;oBACtCN,cAAc,CAACvE,IAAf,EAAoBjI,SAClBA,GAAC+M,sBAAsB,CAACL,SAAD,CAAvB,IAAqCI,WADnB,IAApB;kBAGD;gBACF,CAPI,CAAP;cASD;;cAID,IAAIE,gBAAgB,CAACN,SAAD,CAApB,EAAiC;gBAC/BO,QAAQ,GAAGP,SAAX;cACD,CAFD,MAEO;gBAELO,QAAQ,GAAGjB,WAAW,CAACU,SAAS,CAAC/K,IAAV,CAAe1C,KAAhB,CAAtB;gBACAgF,yBAAoB,YAApB,GAAoBI,oBAAoC,CAApC,CAApB,GAAiEA,gEAAjE;cACD;;cAED,IAAI4I,QAAQ,IAAIA,QAAQ,CAACC,aAAzB,EAAwC;gBAChCA,aAAa,GAAGD,QAAQ,CAACC,aAAT,CAAuBvL,IAAvB,CAA4B1C,KAA5C;;gBACN,IAAIoN,WAAW,CAAC7C,eAAZ,CAA4BmC,SAA5B,EAAuCuB,aAAvC,EAAsDnD,OAAtD,CAAJ,EAAoE;kBAClE,WAAO,KAAKuC,mBAAL,CACLW,QAAQ,CAACV,YADJ,EAELZ,SAFK,EAGLU,WAHK,EAIL5H,IAJK,CAIA,0BAAc;oBACnB+H,cAAc,CAACvE,IAAf,CAAoBkF,cAApB;kBACD,CANM,CAAP;gBAOD;cACF;;;;WAvC4C;QAwC9C,CAxCK;;QA0CN,WAAOtL,OAAO,CAACuL,GAAR,CAAYb,YAAY,CAACc,UAAb,CAAwBC,GAAxB,CAA4Bb,OAA5B,CAAZ,EAAkDhI,IAAlD,CAAuD;UAC5D,OAAO8I,cAAc,CAACf,cAAD,CAArB;QACD,CAFM,CAAP;;;EAGD,CArDa;;EAuDA7C,oCAAd,UACE6D,KADF,EAEE7B,SAFF,EAGEU,WAHF,EAG0B;;;;;;;QAEhBjL,SAAS,GAAKiL,WAAW,UAAzB;QACFoB,SAAS,GAAGD,KAAK,CAAC7L,IAAN,CAAW1C,KAAvB;QACAyO,gBAAgB,GAAGX,sBAAsB,CAACS,KAAD,CAAzC;QACAG,SAAS,GAAGF,SAAS,KAAKC,gBAA1B;QACAE,aAAa,GAAGjC,SAAS,CAAC+B,gBAAD,CAAT,IAA+B/B,SAAS,CAAC8B,SAAD,CAAxD;QACFI,aAAa,GAAGhM,OAAO,CAACC,OAAR,CAAgB8L,aAAhB,CAAhB;;QAMJ,IACE,CAACvB,WAAW,CAACrC,sBAAb,IACA,KAAK8D,oBAAL,CAA0BN,KAA1B,CAFF,EAGE;UACMO,YAAY,GAChBpC,SAAS,CAACqC,UAAV,IAAwB3B,WAAW,CAACD,oBADhC;UAEA6B,WAAW,GAAG,KAAK1E,SAAL,IAAkB,KAAKA,SAAL,CAAewE,YAAf,CAAhC;;UACN,IAAIE,WAAJ,EAAiB;YACTnM,OAAO,GAAGmM,WAAW,CAACN,SAAS,GAAGF,SAAH,GAAeC,gBAAzB,CAArB;;YACN,IAAI5L,OAAJ,EAAa;cACX+L,aAAa,GAAGhM,OAAO,CAACC,OAAR,CAAgBA,OAAO,CACrC6J,SADqC,EAErCuC,wBAAwB,CAACV,KAAD,EAAQpM,SAAR,CAFa,EAGrCiL,WAAW,CAACtC,OAHyB,EAIrC;gBAAEyD,KAAK,OAAP;gBAASxB,WAAW,EAAEK,WAAW,CAACL;cAAlC,CAJqC,CAAvB,CAAhB;YAMD;UACF;QACF;;QAED,WAAO6B,aAAa,CAACpJ,IAAd,CAAmB,UAACxC,MAAD,EAAuB;UAAtB;YAAAA;UAAsB;;UAG/C,IAAIuL,KAAK,CAACW,UAAV,EAAsB;YACpBX,KAAK,CAACW,UAAN,CAAiBxO,OAAjB,CAAyB,qBAAS;cAChC,IAAIyO,SAAS,CAACzM,IAAV,CAAe1C,KAAf,KAAyB,QAAzB,IAAqCmP,SAAS,CAAClD,SAAnD,EAA8D;gBAC5DkD,SAAS,CAAClD,SAAV,CAAoBvL,OAApB,CAA4B,eAAG;kBAC7B,IAAIyL,GAAG,CAACzJ,IAAJ,CAAS1C,KAAT,KAAmB,IAAnB,IAA2BmM,GAAG,CAACnM,KAAJ,CAAUoM,IAAV,KAAmB,aAAlD,EAAiE;oBAC/DgB,WAAW,CAACzB,iBAAZ,CAA8BQ,GAAG,CAACnM,KAAJ,CAAUA,KAAxC,IAAiDgD,MAAjD;kBACD;gBACF,CAJD;cAKD;YACF,CARD;UASD;;UAGD,IAAI,CAACuL,KAAK,CAACjB,YAAX,EAAyB;YACvB,OAAOtK,MAAP;UACD;;UAID,IAAIA,MAAM,IAAI,IAAd,EAAoB;YAElB,OAAOA,MAAP;UACD;;UAED,IAAI/C,KAAK,CAACC,OAAN,CAAc8C,MAAd,CAAJ,EAA2B;YACzB,OAAO9B,KAAI,CAACkO,uBAAL,CAA6Bb,KAA7B,EAAoCvL,MAApC,EAA4CoK,WAA5C,CAAP;UACD;;UAGD,IAAImB,KAAK,CAACjB,YAAV,EAAwB;YACtB,OAAOpM,KAAI,CAACmM,mBAAL,CACLkB,KAAK,CAACjB,YADD,EAELtK,MAFK,EAGLoK,WAHK,CAAP;UAKD;QACF,CAvCM,CAAP;;;EAwCD,CA5Ea;;EA8EN1C,+CAAR,UACE6D,KADF,EAEEvL,MAFF,EAGEoK,WAHF,EAG0B;IAH1B;;IAKE,OAAOxK,OAAO,CAACuL,GAAR,CACLnL,MAAM,CAACqL,GAAP,CAAW,gBAAI;MACb,IAAIgB,IAAI,KAAK,IAAb,EAAmB;QACjB,OAAO,IAAP;MACD;;MAGD,IAAIpP,KAAK,CAACC,OAAN,CAAcmP,IAAd,CAAJ,EAAyB;QACvB,OAAOnO,KAAI,CAACkO,uBAAL,CAA6Bb,KAA7B,EAAoCc,IAApC,EAA0CjC,WAA1C,CAAP;MACD;;MAGD,IAAImB,KAAK,CAACjB,YAAV,EAAwB;QACtB,OAAOpM,KAAI,CAACmM,mBAAL,CAAyBkB,KAAK,CAACjB,YAA/B,EAA6C+B,IAA7C,EAAmDjC,WAAnD,CAAP;MACD;IACF,CAdD,CADK,CAAP;EAiBD,CAtBO;;EAuBV;AAAC,CAzYD;;SCpEgBkC,UAAaC,OAAoB;EAC/C,IAAMtM,SAAS,GAAG,IAAIhB,GAAJ,EAAlB;EACA,IAAIuN,GAAG,GAAwB,IAA/B;EACA,OAAO,IAAI5P,UAAJ,CAAkB,oBAAQ;IAC/BqD,SAAS,CAACkD,GAAV,CAAcpE,QAAd;IACAyN,GAAG,GAAGA,GAAG,IAAID,KAAK,CAAC9L,SAAN,CAAgB;MAC3BV,IAAI,YAAC/C,KAAD,EAAM;QACRiD,SAAS,CAACvC,OAAV,CAAkB,eAAG;UAAI,UAAG,CAACqC,IAAJ,IAAYkG,GAAG,CAAClG,IAAJ,CAAS/C,KAAT,CAAZ;QAA2B,CAApD;MACD,CAH0B;MAI3BwD,KAAK,YAACA,KAAD,EAAM;QACTP,SAAS,CAACvC,OAAV,CAAkB,eAAG;UAAI,UAAG,CAAC8C,KAAJ,IAAayF,GAAG,CAACzF,KAAJ,CAAUA,KAAV,CAAb;QAA6B,CAAtD;MACD,CAN0B;MAO3BiM,QAAQ;QACNxM,SAAS,CAACvC,OAAV,CAAkB,eAAG;UAAI,UAAG,CAAC+O,QAAJ,IAAgBxG,GAAG,CAACwG,QAAJ,EAAhB;QAA8B,CAAvD;MACD;IAT0B,CAAhB,CAAb;IAWA,OAAO;MACL,IAAIxM,SAAS,CAACC,MAAV,CAAiBnB,QAAjB,KAA8B,CAACkB,SAAS,CAACE,IAAzC,IAAiDqM,GAArD,EAA0D;QACxDA,GAAG,CAACjM,WAAJ;QACAiM,GAAG,GAAG,IAAN;MACD;IACF,CALD;EAMD,CAnBM,CAAP;AAoBD;;AAID,SAAgBE,QAAhB,CACEC,UADF,EAEE/I,KAFF,EAEqC;EAEnC,OAAO,IAAIhH,UAAJ,CAAkB,oBAAQ;IACvB;IAAA,IAAM4D,sBAAN;IAAA,IAAaiM,4BAAb;IACR,IAAIG,eAAe,GAAG,CAAtB;IACA,IAAIC,SAAS,GAAG,KAAhB;IAEA,IAAMC,OAAO,GAAgB;MAC3B/M,IAAI,EAAJ,UAAK/C,KAAL,EAAU;QACR,EAAE4P,eAAF;QACA,IAAIhN,OAAJ,CAAY,mBAAO;UACjBC,OAAO,CAAC+D,KAAK,CAAC5G,KAAD,CAAN,CAAP;QACD,CAFD,EAEGwF,IAFH,CAGE,kBAAM;UACJ,EAAEoK,eAAF;UACA7M,IAAI,IAAIA,IAAI,CAACgN,IAAL,CAAUhO,QAAV,EAAoBiB,MAApB,CAAR;UACA6M,SAAS,IAAIC,OAAO,CAACL,QAAR,EAAb;QACD,CAPH,EAQE,aAAC;UACC,EAAEG,eAAF;UACApM,KAAK,IAAIA,KAAK,CAACuM,IAAN,CAAWhO,QAAX,EAAqBiO,CAArB,CAAT;QACD,CAXH;MAaD,CAhB0B;MAiB3BxM,KAAK,YAACwM,CAAD,EAAE;QACLxM,KAAK,IAAIA,KAAK,CAACuM,IAAN,CAAWhO,QAAX,EAAqBiO,CAArB,CAAT;MACD,CAnB0B;MAoB3BP,QAAQ;QACNI,SAAS,GAAG,IAAZ;;QACA,IAAI,CAACD,eAAL,EAAsB;UACpBH,QAAQ,IAAIA,QAAQ,CAACM,IAAT,CAAchO,QAAd,CAAZ;QACD;MACF;IAzB0B,CAA7B;IA4BA,IAAMyN,GAAG,GAAGG,UAAU,CAAClM,SAAX,CAAqBqM,OAArB,CAAZ;IACA,OAAO;MAAM,UAAG,CAACvM,WAAJ;IAAiB,CAA9B;EACD,CAnCM,CAAP;AAoCD;;AC9BO;;AAgBR;EA6BE,sBAAYxC,EAAZ,EAkBC;QAjBCkP;QACApO;QAAAqO;QACA9G;QACA+G;QAAAC;MAAA;IAAA;QACAC;QAAAC;QACAC;QAAAC;QACAC;QACArJ;IAnCK,qBAA+B,IAAI+B,aAAJ,EAA/B;IACA,kBAAyB,IAAII,UAAJ,EAAzB;IAKC,uBAA0C,EAA1C;IAQA,iBAAY,CAAZ;IAIA,eAAkC,IAAImH,GAAJ,EAAlC;IAOA,2BAAsB,IAAIA,GAAJ,EAAtB;IAujBA,sBAAiB,KAAKC,aAAa,GAAGC,OAAH,GAAaF,GAA/B,GAAjB;IAkcA,+BAA0B,IAAIA,GAAJ,EAA1B;IAgPA,4BAAuB,IAAIA,GAAJ,EAAvB;IAptCN,KAAKT,IAAL,GAAYA,IAAZ;IACA,KAAKC,kBAAL,GAA0BA,kBAA1B;IACA,KAAKpJ,SAAL,GAAiBsC,KAAjB;IACA,KAAKgH,WAAL,GAAmBA,WAAnB;IACA,KAAKI,eAAL,GAAuBA,eAAvB;IACA,KAAKC,UAAL,GAAkBA,UAAU,IAAI,IAAI/F,UAAJ,CAAe;MAAEN,KAAK,EAAEhB,KAAK,CAACyH,QAAN;IAAT,CAAf,CAAhC;IACA,KAAKP,OAAL,GAAeA,OAAf;IACA,KAAKlJ,sBAAL,GAA8B,CAAC,CAACA,sBAAhC;EACD;;EAMM0J,8BAAP;IAAA;;IACE,KAAKC,OAAL,CAAarQ,OAAb,CAAqB,UAACsQ,KAAD,EAAQ5O,OAAR,EAAe;MAClClB,KAAI,CAAC+P,oBAAL,CAA0B7O,OAA1B;IACD,CAFD;IAIA,KAAK8O,mBAAL,CAAyBxQ,OAAzB,CAAiC,kBAAM;MACrCoC,MAAM,CACJkC,oEAAoEmM,cAApE,CAAoE,gDAApE,CADI,CAAN;IAGD,CAJD;EAKD,CAVM;;EAYML,gCAAb,UAAuB/P,EAAvB,EAWkB;QAVhBuI;QACAnH;QACAiP;QACAC;QACAxP;QAAAyP;QACAnB;QAAAoB;QACAC;QACAnB;QAAA/L;QACAD;QACAkM;QAAAzF;;;;;;;;;YAEA9F,yBAEE,YAFF,GAEEI,sBAFF,GAEEA,kHAFF;YAKAJ,YACGyE,QADH,KACG,YADH,GAC6BrE,yDAD7B,GAC6BA,gOAD7B;YAKMiE,UAAU,GAAG,KAAKhH,eAAL,EAAb;YACNiH,QAAQ,GAAG,KAAKlB,SAAL,CAAekB,QAAf,EAAyBxD,QAApC;YAEA,KAAK2L,QAAL,CAAcpI,UAAd,EAA0B;cAAM,OAAC;gBAAEvD,QAAQ,EAAEwD;cAAZ,CAAD;YAAwB,CAAxD;YAEAnH,SAAS,GAAG,KAAKuP,YAAL,CAAkBpI,QAAlB,EAA4BnH,SAA5B,CAAZ;iBAEI,KAAKiG,SAAL,CAAekB,QAAf,EAAyBjB,kBAAzB;YACU,WAAM,KAAKoI,UAAL,CAAgBlI,oBAAhB,CAAqCe,QAArC,EAA+CnH,SAA/C,EAA0D2I,OAA1D,CAAN;;;YAAZ3I,SAAS,GAAGwP,SAAZ;;;;YAIIC,yBAAyB,GAE3B;cACF,IAAMC,GAAG,GAA4C,EAArD;;cAEA,IAAIR,mBAAJ,EAAyB;gBACvBnQ,KAAI,CAAC6P,OAAL,CAAarQ,OAAb,CAAqB,UAACK,EAAD,EAAsBqB,OAAtB,EAA6B;sBAA1B0P;;kBACtB,IAAIA,eAAJ,EAAqB;oBACX;;oBACR,IACErP,SAAS,IACTnC,cAAc,CAACyP,IAAf,CAAoBsB,mBAApB,EAAyC5O,SAAzC,CAFF,EAGE;sBACAoP,GAAG,CAACzP,OAAD,CAAH,GAAe;wBACb2P,OAAO,EAAEV,mBAAmB,CAAC5O,SAAD,CADf;wBAEbD,KAAK,EAAEtB,KAAI,CAACgD,UAAL,CAAgBC,GAAhB,CAAoB/B,OAApB;sBAFM,CAAf;oBAID;kBACF;gBACF,CAbD;cAcD;;cAED,OAAOyP,GAAP;YACD,CAvBK;;YAyBN,KAAKG,aAAL,CAAmBC,YAAnB,CACE5I,UADF,EAEEC,QAFF,EAGEnH,SAHF;YAMA,KAAK2E,SAAL,CAAeoL,gBAAf,CAAgC;cAC9B7I,UAAU,YADoB;cAE9BvD,QAAQ,EAAEwD,QAFoB;cAG9BnH,SAAS,WAHqB;cAI9BgQ,aAAa,EAAEP,yBAAyB,EAJV;cAK9BQ,MAAM,EAAEZ,iBALsB;cAM9BJ,kBAAkB;YANY,CAAhC;YASA,KAAKpK,gBAAL;YAEMqL,IAAI,GAAG,IAAP;YAEN,WAAO,IAAIzP,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAgB;cACjC,IAAIwP,WAAJ;cACA,IAAI9O,KAAJ;cAEA6O,IAAI,CAACE,qBAAL,CACEjJ,QADF,EACU/E,sBAEHuG,OAFG,GAEI;gBACVsG,kBAAkB;cADR,CAFJ,CADV,EAMEjP,SANF,EAOE,KAPF,EAQEsB,SARF,CAQY;gBACVV,IAAI,EAAJ,UAAKC,MAAL,EAA2B;kBACzB,IAAIwP,qBAAqB,CAACxP,MAAD,CAArB,IAAiCsB,WAAW,KAAK,MAArD,EAA6D;oBAC3Dd,KAAK,GAAG,IAAIpC,WAAJ,CAAgB;sBACtBX,aAAa,EAAEuC,MAAM,CAACwB;oBADA,CAAhB,CAAR;oBAGA;kBACD;;kBAED6N,IAAI,CAACL,aAAL,CAAmBS,kBAAnB,CAAsCpJ,UAAtC;;kBAEA,IAAIhF,WAAW,KAAK,UAApB,EAAgC;oBAC9BgO,IAAI,CAACvL,SAAL,CAAe2L,kBAAf,CAAkC;sBAChCpJ,UAAU,YADsB;sBAEhCrG,MAAM,QAF0B;sBAGhC8C,QAAQ,EAAEwD,QAHsB;sBAIhCnH,SAAS,WAJuB;sBAKhCgQ,aAAa,EAAEP,yBAAyB,EALR;sBAMhCQ,MAAM,EAAEZ;oBANwB,CAAlC;kBAQD;;kBAEDc,WAAW,GAAGtP,MAAd;gBACD,CAvBS;gBAyBVQ,KAAK,EAAL,UAAMnD,GAAN,EAAgB;kBACdgS,IAAI,CAACL,aAAL,CAAmBU,iBAAnB,CAAqCrJ,UAArC,EAAiDhJ,GAAjD;kBACAgS,IAAI,CAACvL,SAAL,CAAe6L,oBAAf,CAAoC;oBAClCtJ,UAAU,YADwB;oBAElC+H,kBAAkB;kBAFgB,CAApC;kBAIAiB,IAAI,CAACrL,gBAAL;kBACAqL,IAAI,CAACZ,QAAL,CAAcpI,UAAd,EAA0B;oBAAM,OAAC;sBAAEvD,QAAQ,EAAE;oBAAZ,CAAD;kBAAoB,CAApD;kBACAhD,MAAM,CACJ,IAAI1B,WAAJ,CAAgB;oBACdP,YAAY,EAAER;kBADA,CAAhB,CADI,CAAN;gBAKD,CAtCS;gBAwCVoP,QAAQ,EAAR;kBACE,IAAIjM,KAAJ,EAAW;oBACT6O,IAAI,CAACL,aAAL,CAAmBU,iBAAnB,CAAqCrJ,UAArC,EAAiD7F,KAAjD;kBACD;;kBAED6O,IAAI,CAACvL,SAAL,CAAe6L,oBAAf,CAAoC;oBAClCtJ,UAAU,YADwB;oBAElC+H,kBAAkB;kBAFgB,CAApC;kBAKAiB,IAAI,CAACrL,gBAAL;;kBAEA,IAAIxD,KAAJ,EAAW;oBACTV,MAAM,CAACU,KAAD,CAAN;oBACA;kBACD;;kBAID,IAAI,OAAO8N,cAAP,KAA0B,UAA9B,EAA0C;oBACxCA,cAAc,GAAGA,cAAc,CAACgB,WAAD,CAA/B;kBACD;;kBAED,IAAMM,oBAAoB,GAEpB,EAFN;;kBAIA,IAAI7S,eAAe,CAACuR,cAAD,CAAnB,EAAqC;oBACnCA,cAAc,CAAC5Q,OAAf,CAAuB,wBAAY;sBACjC,IAAI,OAAOmS,YAAP,KAAwB,QAA5B,EAAsC;wBACpCR,IAAI,CAACtB,OAAL,CAAarQ,OAAb,CAAqB,UAACK,EAAD,EAAoB;8BAAjB+Q;;0BACtB,IACEA,eAAe,IACfA,eAAe,CAACrP,SAAhB,KAA8BoQ,YAFhC,EAGE;4BACAD,oBAAoB,CAAC5J,IAArB,CAA0B8I,eAAe,CAAC5M,OAAhB,EAA1B;0BACD;wBACF,CAPD;sBAQD,CATD,MASO;wBACL,IAAM4N,YAAY,GAAiB;0BACjCtQ,KAAK,EAAEqQ,YAAY,CAACrQ,KADa;0BAEjCL,SAAS,EAAE0Q,YAAY,CAAC1Q,SAFS;0BAGjCkC,WAAW,EAAE;wBAHoB,CAAnC;;wBAMA,IAAIwO,YAAY,CAAC/H,OAAjB,EAA0B;0BACxBgI,YAAY,CAAChI,OAAb,GAAuB+H,YAAY,CAAC/H,OAApC;wBACD;;wBAED8H,oBAAoB,CAAC5J,IAArB,CAA0BqJ,IAAI,CAAC7P,KAAL,CAAWsQ,YAAX,CAA1B;sBACD;oBACF,CAvBD;kBAwBD;;kBAEDlQ,OAAO,CAACuL,GAAR,CACEoD,mBAAmB,GAAGqB,oBAAH,GAA0B,EAD/C,EAEEpN,IAFF,CAEO;oBACL6M,IAAI,CAACZ,QAAL,CAAcpI,UAAd,EAA0B;sBAAM,OAAC;wBAAEvD,QAAQ,EAAE;sBAAZ,CAAD;oBAAoB,CAApD;;oBAEA,IACExB,WAAW,KAAK,QAAhB,IACAgO,WADA,IAEAE,qBAAqB,CAACF,WAAD,CAHvB,EAIE;sBACA,OAAOA,WAAW,CAAC9N,MAAnB;oBACD;;oBAED3B,OAAO,CAACyP,WAAD,CAAP;kBACD,CAdD;gBAeD;cA7GS,CARZ;YAuHD,CA3HM,CAAP;;;;EA4HD,CA1MY;;EA4MAxB,oCAAb,UACE1O,OADF,EAEER,OAFF,EAGEmR,SAHF,EAOEnJ,mBAPF,EAO8B;;;;;;;;;YAG1B7I,KAGEa,OAAO,SAHT,UAAQ,mBAAG,IAAH,GAAOb,EAAf,EACAc,KAEED,OAAO,YAHT,EACAyC,WAAW,mBAAG,aAAH,GAAgBxC,EAD3B,EAEAsO,KACEvO,OAAO,QAHT,EAEAkJ,OAAO,mBAAG,EAAH,GAAKqF,EAFZ;YAKI3N,KAAK,GAAG,KAAK4F,SAAL,CAAexG,OAAO,CAACY,KAAvB,EAA8BsD,QAAtC;YAEF3D,SAAS,GAAG,KAAKuP,YAAL,CAAkBlP,KAAlB,EAAyBZ,OAAO,CAACO,SAAjC,CAAZ;iBAEA,KAAKiG,SAAL,CAAe5F,KAAf,EAAsB6F,kBAAtB;YACU,WAAM,KAAKoI,UAAL,CAAgBlI,oBAAhB,CAAqC/F,KAArC,EAA4CL,SAA5C,EAAuD2I,OAAvD,CAAN;;;YAAZ3I,SAAS,GAAGoO,SAAZ;;;;YAGF3O,OAAO,yBAAQA,OAAR,GAAe;cAAEO,SAAS;YAAX,CAAf,CAAP;YAGM6Q,aAAa,GACjB3O,WAAW,KAAK,cAAhB,IAAkCA,WAAW,KAAK,UAD9C;YAEF4O,WAAW,GAAGD,aAAd;;YAIJ,IAAI,CAACA,aAAL,EAAoB;cACZ3C,KAAuB,KAAKvJ,SAAL,CAAe+J,QAAf,GAA0BvE,IAA1B,CAA+B;gBAC1D9J,KAAK,OADqD;gBAE1DL,SAAS,WAFiD;gBAG1DqK,iBAAiB,EAAE,IAHuC;gBAI1DC,UAAU,EAAE;cAJ8C,CAA/B,CAAvB,EAAEgD,QAAQ,cAAV,EAAYzM,MAAM,YAAlB;cAQNiQ,WAAW,GAAG,CAACxD,QAAD,IAAapL,WAAW,KAAK,mBAA3C;cACAiO,WAAW,GAAGtP,MAAd;YACD;;YAEGkQ,WAAW,GACbD,WAAW,IAAI5O,WAAW,KAAK,YAA/B,IAA+CA,WAAW,KAAK,SAD7D;YAIJ,IAAI6G,aAAa,CAAC,CAAC,MAAD,CAAD,EAAW1I,KAAX,CAAjB,EAAoC0Q,WAAW,GAAG,IAAd;YAE9BC,SAAS,GAAG,KAAKC,SAAL,EAAZ;YAGAC,MAAM,GAAGhP,WAAW,KAAK,UAAhB,GACX,KAAKiP,gBAAL,CAAsBlR,OAAtB,EAA+BI,KAA/B,EAAsCZ,OAAtC,CADW,GAEXgC,SAFE;YAKN,KAAK6N,QAAL,CAAcrP,OAAd,EAAuB;cAAM,OAAC;gBAC5B0D,QAAQ,EAAEtD,KADkB;gBAE5B+Q,aAAa,EAAEJ,SAFa;gBAG5BK,WAAW,EAAE,IAHe;gBAI5BH,MAAM;cAJsB,CAAD;YAK3B,CALF;YAOA,KAAKI,UAAL,CAAgB7J,mBAAhB;YAEA,KAAK1F,UAAL,CAAgBwP,SAAhB,CAA0B;cACxBtR,OAAO,SADiB;cAExB0D,QAAQ,EAAEtD,KAFc;cAGxBmR,sBAAsB,EAAET,WAHA;cAIxB/Q,SAAS,WAJe;cAKxByR,MAAM,EAAEb,SAAS,KAAKxR,SAAS,CAACsS,IALR;cAMxBC,SAAS,EAAEf,SAAS,KAAKxR,SAAS,CAAC2D,OANX;cAOxByE,QAAQ,UAPgB;cAQxBC,mBAAmB;YARK,CAA1B;YAWA,KAAK5C,gBAAL;;YAEA,IAAIkM,WAAJ,EAAiB;cACTa,aAAa,GAAG,KAAKC,YAAL,CAAqB;gBACzCb,SAAS,WADgC;gBAEzC/Q,OAAO,SAFkC;gBAGzC0D,QAAQ,EAAEtD,KAH+B;gBAIzCZ,OAAO,SAJkC;gBAKzCgI,mBAAmB;cALsB,CAArB,EAMnBlB,KANmB,CAMb,iBAAK;gBAGZ,IAAItI,aAAa,CAACoD,KAAD,CAAjB,EAA0B;kBACxB,MAAMA,KAAN;gBACD,CAFD,MAEO;kBACL,IAAI2P,SAAS,IAAIjS,KAAI,CAAC+S,QAAL,CAAc7R,OAAd,EAAuBmR,aAAxC,EAAuD;oBACrDrS,KAAI,CAACgD,UAAL,CAAgBgQ,cAAhB,CAA+B9R,OAA/B,EAAwCoB,KAAxC,EAA+CoG,mBAA/C;;oBACA1I,KAAI,CAACuS,UAAL,CAAgBrR,OAAhB;;oBACAlB,KAAI,CAACuS,UAAL,CAAgB7J,mBAAhB;;oBACA1I,KAAI,CAAC8F,gBAAL;kBACD;;kBACD,MAAM,IAAI5F,WAAJ,CAAgB;oBAAEP,YAAY,EAAE2C;kBAAhB,CAAhB,CAAN;gBACD;cACF,CApBqB,CAAhB;;cAwBN,IAAIa,WAAW,KAAK,mBAApB,EAAyC;gBACvC,WAAO0P,aAAP;cACD;;cAIDA,aAAa,CAACrL,KAAd,CAAoB,aAAQ,CAA5B;YACD;;YAID,KAAKxE,UAAL,CAAgB2F,qBAAhB,CAAsCzH,OAAtC,EAA+C,CAAC8Q,WAAhD;YACA,KAAKO,UAAL,CAAgBrR,OAAhB;YACA,KAAKqR,UAAL,CAAgB7J,mBAAhB;;YAEA,IAAI,KAAKxB,SAAL,CAAe5F,KAAf,EAAsB2R,kBAA1B,EAA8C;cAC5C,WAAO,KAAK1D,UAAL,CAAgB2D,YAAhB,CAA6B;gBAClCtO,QAAQ,EAAEtD,KADwB;gBAElCqI,YAAY,EAAE;kBAAElH,IAAI,EAAE2O;gBAAR,CAFoB;gBAGlCxH,OAAO,SAH2B;gBAIlC3I,SAAS,WAJyB;gBAKlC4I,sBAAsB,EAAE;cALU,CAA7B,EAMJvF,IANI,CAMC,UAACxC,MAAD,EAAuB;gBAC7B9B,KAAI,CAACmT,eAAL,CACEjS,OADF,EAEEY,MAFF,EAGEpB,OAHF,EAIEgI,mBAJF;;gBAMA1I,KAAI,CAAC8F,gBAAL;;gBACA,OAAOhE,MAAP;cACD,CAfM,CAAP;YAgBD;;YAED,KAAKgE,gBAAL;YAIA,WAAO;cAAErD,IAAI,EAAE2O;YAAR,CAAP;;;;EACD,CAjJY;;EAmJLxB,yCAAR,UACE1O,OADF,EAEEY,MAFF,EAGEjC,EAHF,EAQE6I,mBARF,EAQ8B;QAJ1BvF;QACAlC;QACAmC;;IAIF,IAAID,WAAW,KAAK,UAApB,EAAgC;MAC9B,KAAKoN,QAAL,CAAcrP,OAAd,EAAuB;QAAM,OAAC;UAC5BkS,OAAO,EAAE;YAAEtR,MAAM,EAAEA,MAAM,CAACW,IAAjB;YAAuB8L,QAAQ,EAAE;UAAjC;QADmB,CAAD;MAE3B,CAFF;IAGD,CAJD,MAIO;MACL,KAAK3I,SAAL,CAAeuN,eAAf,CACErR,MADF,EAEE,KAAKiR,QAAL,CAAc7R,OAAd,EAAuB0D,QAFzB,EAGE3D,SAHF,EAIEyH,mBAJF,EAKEtF,WAAW,KAAK,QAAhB,IAA4BA,WAAW,KAAK,KAL9C;IAOD;EACF,CAvBO;;EA2BDwM,kDAAP,UACE1O,OADF,EAEER,OAFF,EAGEG,QAHF,EAG0C;IAH1C;;IAKE,SAASwS,MAAT,CAAgB1L,MAAhB,EAA0CC,QAA1C,EAAuD;MACrD,IAAI/G,QAAQ,CAAC8G,MAAD,CAAZ,EAAsB;QACpB,IAAI;UACF9G,QAAQ,CAAC8G,MAAD,CAAR,CAAkBC,QAAlB;QACD,CAFD,CAEE,OAAOkH,CAAP,EAAU;UACVhL;QACD;MACF,CAND,MAMO,IAAI6D,MAAM,KAAK,OAAf,EAAwB;QAC7B7D,yBAAyB,YAAzB,IAAyBI,yBAAzB;MACD;IACF;;IAED,OAAO,UACLnB,eADK,EAELqQ,OAFK,EAEwB;MAG7BpT,KAAI,CAACuS,UAAL,CAAgBrR,OAAhB,EAAyB,KAAzB;;MAIA,IAAI,CAAC6B,eAAL,EAAsB;;MAEhB;MAAA,IAAE6N,oCAAF;MAAA,IAAmBhM,sBAAnB;;MAEN,IAAMzB,WAAW,GAAGyN,eAAe,GAC/BA,eAAe,CAAClQ,OAAhB,CAAwByC,WADO,GAE/BzC,OAAO,CAACyC,WAFZ;MAKA,IAAIA,WAAW,KAAK,SAApB,EAA+B;MAE/B,IAAMN,OAAO,GAAGtE,wBAAwB,CAACwE,eAAe,CAACvE,aAAjB,CAAxC;MACA,IAAMoE,UAAU,GAAGgO,eAAe,IAAIA,eAAe,CAAC0C,aAAhB,EAAtC;MAEA,IAAMC,oBAAoB,GAAG,CAAC,EAC5B3Q,UAAU,IACVA,UAAU,CAACpE,aAAX,KAA6BuE,eAAe,CAACvE,aAFjB,CAA9B;MAKA,IAAMgV,qBAAqB,GACzB9S,OAAO,CAAC4K,iBAAR,IACC,CAAC8H,OAAD,IAAYrQ,eAAe,CAACuE,iBAD7B,IAECiM,oBAAoB,IAAI7S,OAAO,CAAC+S,2BAFjC,IAGAtQ,WAAW,KAAK,YAHhB,IAIAA,WAAW,KAAK,mBALlB;;MAOA,IAAIN,OAAO,IAAI,CAAC2Q,qBAAhB,EAAuC;QACrC;MACD;;MAED,IAAME,gBAAgB,GAAG7U,eAAe,CAACkE,eAAe,CAACxD,aAAjB,CAAxC;MAEA,IAAM6D,WAAW,GAAgBwN,eAAe,IAC3CA,eAAe,CAAClQ,OAAhB,CAAwB0C,WADI,IAE5B1C,OAAO,CAAC0C,WAFoB,IAG5B,MAHL;;MAOA,IAAIA,WAAW,KAAK,MAAhB,IAA0BsQ,gBAA1B,IAA8C3Q,eAAe,CAACpD,YAAlE,EAAgF;QAC9E,OAAO0T,MAAM,CAAC,OAAD,EAAU,IAAInT,WAAJ,CAAgB;UACrCX,aAAa,EAAEwD,eAAe,CAACxD,aADM;UAErCI,YAAY,EAAEoD,eAAe,CAACpD;QAFO,CAAhB,CAAV,CAAb;MAID;;MAED,IAAI;QACF,IAAI8C,IAAI,SAAR;QACA,IAAIkR,SAAS,SAAb;;QAEA,IAAIP,OAAJ,EAAa;UAOX,IAAIjQ,WAAW,KAAK,UAAhB,IAA8BA,WAAW,KAAK,cAAlD,EAAkE;YAChEnD,KAAI,CAACuQ,QAAL,CAAcrP,OAAd,EAAuB;cAAM,OAAC;gBAAEkS,OAAO,EAAE;cAAX,CAAD;YAAmB,CAAhD;UACD;;UAED3Q,IAAI,GAAG2Q,OAAO,CAACtR,MAAf;UACA6R,SAAS,GAAG,CAACP,OAAO,CAAC7E,QAArB;QACD,CAbD,MAaO;UACL,IAAM5L,SAAS,GAAGiO,eAAe,IAAIA,eAAe,CAACgD,YAAhB,EAArC;UACA,IAAMC,kBAAkB,GACtBzQ,WAAW,KAAK,MAAhB,IACA,CAACT,SAAS,IAAIA,SAAS,CAACpD,aAAxB,MACEwD,eAAe,CAACxD,aAHpB;;UAKA,IAAIqD,UAAU,IAAIA,UAAU,CAACH,IAAzB,IAAiC,CAACoR,kBAAtC,EAA0D;YACxDpR,IAAI,GAAGG,UAAU,CAACH,IAAlB;YACAkR,SAAS,GAAG,KAAZ;UACD,CAHD,MAGO;YACL,IAAMG,UAAU,GAAG9T,KAAI,CAAC4F,SAAL,CAAe+J,QAAf,GAA0BvE,IAA1B,CAA+B;cAChD9J,KAAK,EAAEsD,QADyC;cAEhD3D,SAAS,EACP8B,eAAe,CAACuE,iBAAhB,IACAvE,eAAe,CAAC9B,SAJ8B;cAKhDqK,iBAAiB,EAAE,IAL6B;cAMhDC,UAAU,EAAE;YANoC,CAA/B,CAAnB;;YASA9I,IAAI,GAAGqR,UAAU,CAAChS,MAAlB;YACA6R,SAAS,GAAG,CAACG,UAAU,CAACvF,QAAxB;UACD;QACF;;QAKD,IAAM9K,KAAK,GAAGkQ,SAAS,IAAI,EACzBjT,OAAO,CAAC4K,iBAAR,IACAnI,WAAW,KAAK,YAFS,CAA3B;QAKA,IAAM4Q,eAAe,GAAyB;UAC5CtR,IAAI,EAAEgB,KAAK,GAAGb,UAAU,IAAIA,UAAU,CAACH,IAA5B,GAAmCA,IADF;UAE5CI,OAAO,SAFqC;UAG5CrE,aAAa,EAAEuE,eAAe,CAACvE,aAHa;UAI5CiF,KAAK;QAJuC,CAA9C;;QAQA,IAAIL,WAAW,KAAK,KAAhB,IAAyBsQ,gBAA7B,EAA+C;UAC7CK,eAAe,CAACzQ,MAAhB,GAAyBP,eAAe,CAACxD,aAAzC;QACD;;QAED8T,MAAM,CAAC,MAAD,EAASU,eAAT,CAAN;MAED,CAhED,CAgEE,OAAOpU,YAAP,EAAqB;QACrB0T,MAAM,CAAC,OAAD,EAAU,IAAInT,WAAJ,CAAgB;UAAEP,YAAY;QAAd,CAAhB,CAAV,CAAN;MACD;IACF,CA1HD;EA2HD,CA5IM;;EA0JAiQ,mCAAP,UAAiBhL,QAAjB,EAAuC;IAC7B;;IAER,IAAI,CAACoP,cAAc,CAACC,GAAf,CAAmBrP,QAAnB,CAAL,EAAmC;MACjC,IAAMsE,KAAK,GAAG,KAAKtD,SAAL,CAAe+J,QAAf,EAAd;MACA,IAAMuE,WAAW,GAAGhL,KAAK,CAACiL,iBAAN,CAAwBvP,QAAxB,CAApB;MACA,IAAMwP,OAAO,GAAGC,qCAAqC,CACnDnL,KAAK,CAACoL,gBAAN,CAAuBJ,WAAvB,CADmD,CAArD;MAGA,IAAMK,WAAW,GAAG,KAAKhF,UAAL,CAAgBgF,WAAhB,CAA4BL,WAA5B,CAApB;MACA,IAAM3M,WAAW,GAAG,KAAKgI,UAAL,CAAgBhI,WAAhB,CAA4B6M,OAA5B,CAApB;MAEA,IAAMI,YAAU,GAAG;QACjB5P,QAAQ,EAAEsP,WADO;QAIjB/M,gBAAgB,EAAEA,gBAAgB,CAAC+M,WAAD,CAJjB;QAKjBjB,kBAAkB,EAAE,KAAK1D,UAAL,CAAgB5B,oBAAhB,CAAqCuG,WAArC,CALH;QAMjBK,WAAW,aANM;QAOjBhN,WAAW,aAPM;QAQjBkN,WAAW,EAAEC,gBAAgB,CAC3BrT,sBAAsB,CAAC6S,WAAD,CADK;MARZ,CAAnB;;MAaA,IAAMjP,GAAG,GAAG,UAAC0P,GAAD,EAAyB;QACnC,IAAIA,GAAG,IAAI,CAACX,cAAc,CAACC,GAAf,CAAmBU,GAAnB,CAAZ,EAAqC;UACnCX,cAAc,CAACY,GAAf,CAAmBD,GAAnB,EAAwBH,YAAxB;QACD;MACF,CAJD;;MAQAvP,GAAG,CAACL,QAAD,CAAH;MACAK,GAAG,CAACiP,WAAD,CAAH;MACAjP,GAAG,CAACsP,WAAD,CAAH;MACAtP,GAAG,CAACsC,WAAD,CAAH;IACD;;IAED,OAAOyM,cAAc,CAAC/Q,GAAf,CAAmB2B,QAAnB,CAAP;EACD,CAxCM;;EA0CCgL,sCAAR,UACEhL,QADF,EAEE3D,SAFF,EAEgC;IAE9B,6BACK,KAAKiG,SAAL,CAAetC,QAAf,EAAyB6P,WAD9B,GAEKxT,SAFL;EAID,CARO;;EAiBD2O,oCAAP,UACElP,OADF,EAEEE,eAFF,EAEwB;IAAtB;MAAAA;IAAsB;;IAEtBkD;IAMApD,OAAO,CAACO,SAAR,GAAoB,KAAKuP,YAAL,CAAkB9P,OAAO,CAACY,KAA1B,EAAiCZ,OAAO,CAACO,SAAzC,CAApB;;IAEA,IAAI,OAAOP,OAAO,CAAC+S,2BAAf,KAA+C,WAAnD,EAAgE;MAC9D/S,OAAO,CAAC+S,2BAAR,GAAsC,KAAtC;IACD;;IAED,IAAIoB,kBAAkB,GAAGxR,aAAK3C,OAAL,CAAzB;;IAEA,OAAO,IAAIe,eAAJ,CAAmC;MACxChB,YAAY,EAAE,IAD0B;MAExCC,OAAO,EAAEmU,kBAF+B;MAGxCjU,eAAe,EAAEA;IAHuB,CAAnC,CAAP;EAKD,CAvBM;;EAyBAgP,+BAAP,UAAgBlP,OAAhB,EAAqC;IAArC;;IACEoD,yBAEE,YAFF,GAEEI,4BAFF,GAEEA,+FACE,sBADF,CAFF;IAMAJ;IAKAA,YACIyE,QADJ,KACI,YADJ,GACIrE,yCADJ,GACIA,UACsD,CACzDxD,yBAFG,EAEH,wDAFG,CADJ;IAKAoD,YACIyE,QADJ,KACI,YADJ,GACIrE,oCADJ,GACIA,qFADJ;IAKA,OAAO,IAAIxC,OAAJ,CAAkC,UAACC,OAAD,EAAUC,MAAV,EAAgB;MACvD,IAAMkT,YAAY,GAAG9U,KAAI,CAAC+U,UAAL,CAAmBrU,OAAnB,EAA4B,KAA5B,CAArB;;MACAV,KAAI,CAACgQ,mBAAL,CAAyB4E,GAAzB,CAA6B,WAASE,YAAY,CAAC5T,OAAnD,EAA8DU,MAA9D;;MACAkT,YAAY,CACThT,MADH,GAEGwC,IAFH,CAEQ3C,OAFR,EAEiBC,MAFjB,EASG0C,IATH,CASQ;QACJ,YAAI,CAAC0L,mBAAL,CAAyBhO,MAAzB,CAAgC,WAAS8S,YAAY,CAAC5T,OAAtD;MAAgE,CAVpE;IAYD,CAfM,CAAP;EAgBD,CAtCM;;EAwCA0O,yCAAP;IACE,OAAOoF,MAAM,CAAC,KAAK9C,SAAL,EAAD,CAAb;EACD,CAFM;;EAIAtC,0CAAP,UAAwB1O,OAAxB,EAAuC;IACrC,KAAK+T,2BAAL,CAAiC/T,OAAjC;IACA,KAAK4E,gBAAL;EACD,CAHM;;EAKC8J,qDAAR,UAAoC1O,OAApC,EAAmD;IACjD,KAAK6E,gBAAL,CAAsB7E,OAAtB;IACA,KAAK8B,UAAL,CAAgB0B,SAAhB,CAA0BxD,OAA1B;IACA,KAAKqR,UAAL,CAAgBrR,OAAhB;EACD,CAJO;;EAMD0O,0CAAP,UAAwB1O,OAAxB,EAAyCgU,QAAzC,EAAgE;IAC9D,KAAK3E,QAAL,CAAcrP,OAAd,EAAuB,UAACrB,EAAD,EAAc;UAAXsV;MACxBA,SAAS,CAAClQ,GAAV,CAAciQ,QAAd;MACA,OAAO;QAAE5C,WAAW,EAAE;MAAf,CAAP;IACD,CAHD;EAID,CALM;;EAOA1C,0CAAP,UACE1O,OADF,EAEE0D,QAFF,EAGElE,OAHF,EAG4B;IAH5B;;IAKU;IACR,IAAIyR,MAAJ,EAAYA,MAAM;;IAClB,IAAM3N,cAAc,GAAG;MACrB,IAAIA,cAAc,GAAG,IAArB;;MACQ;;MACR,IAAIoM,eAAJ,EAAqB;QACnB,IAAMhO,UAAU,GAAGgO,eAAe,CAAC0C,aAAhB,EAAnB;;QACA,IAAI1Q,UAAJ,EAAgB;UACd4B,cAAc,GAAG5B,UAAU,CAACH,IAA5B;QACD;MACF;;MAED,OAAO+B,cAAP;IACD,CAXD;;IAYA,OAAO,KAAKoB,SAAL,CAAe+J,QAAf,GAA0ByF,KAA1B,CAAgC;MACrC9T,KAAK,EAAEsD,QAD8B;MAErC3D,SAAS,EAAEP,OAAO,CAACO,SAFkB;MAGrCsK,UAAU,EAAE,IAHyB;MAIrC/G,cAAc,gBAJuB;MAKrC6Q,QAAQ,EAAE,mBAAO;QACfrV,KAAI,CAACuQ,QAAL,CAAcrP,OAAd,EAAuB;UAAM,OAAC;YAAEoR,WAAW,EAAE,IAAf;YAAqBc,OAAO;UAA5B,CAAD;QAAgC,CAA7D;MACD;IAPoC,CAAhC,CAAP;EASD,CA5BM;;EA+BAxD,4CAAP,UACE1O,OADF,EAEE0P,eAFF,EAEqC;IAEnC,KAAKL,QAAL,CAAcrP,OAAd,EAAuB;MAAM,OAAC;QAAE0P,eAAe;MAAjB,CAAD;IAAqB,CAAlD;EACD,CALM;;EAOAhB,+CAAP,UAA6B1O,OAA7B,EAA4C;IAClC;IACR,KAAKqP,QAAL,CAAcrP,OAAd,EAAuB;MAAM,OAAC;QAAE0P,eAAe,EAAE;MAAnB,CAAD;IAA2B,CAAxD;IACA,IAAIuB,MAAJ,EAAYA,MAAM;EACnB,CAJM;;EAMAvC,oCAAP;IAOE,KAAKI,mBAAL,CAAyBxQ,OAAzB,CAAiC,kBAAM;MACrCoC,MAAM,CAACkC,0JAAD,CAAN;IAGD,CAJD;IAMA,IAAMwR,QAAQ,GAAa,EAA3B;IACA,KAAKzF,OAAL,CAAarQ,OAAb,CAAqB,UAACK,EAAD,EAAsBqB,OAAtB,EAA6B;UAA1B0P;MACtB,IAAIA,eAAJ,EAAqB0E,QAAQ,CAACxN,IAAT,CAAc5G,OAAd;IACtB,CAFD;IAIA,KAAK8B,UAAL,CAAgB4F,KAAhB,CAAsB0M,QAAtB;IACA,KAAKxE,aAAL,CAAmBlI,KAAnB;IAGA,OAAO,KAAKhD,SAAL,CAAegD,KAAf,EAAP;EACD,CAvBM;;EAyBAgH,oCAAP;IAAA;;IAOE,OAAO,KAAK2F,UAAL,GAAkBjR,IAAlB,CAAuB;MAC5B,OAAOtE,KAAI,CAACwV,wBAAL,EAAP;IACD,CAFM,CAAP;EAGD,CAVM;;EAYA5F,kDAAP,UACE6F,cADF,EACiC;IADjC;;IACE;MAAAA;IAA+B;;IAE/B,IAAMC,uBAAuB,GAAsC,EAAnE;IAEA,KAAK7F,OAAL,CAAarQ,OAAb,CAAqB,UAACK,EAAD,EAAsBqB,OAAtB,EAA6B;UAA1B0P;;MACtB,IAAIA,eAAJ,EAAqB;QACnB,IAAMzN,WAAW,GAAGyN,eAAe,CAAClQ,OAAhB,CAAwByC,WAA5C;QAEAyN,eAAe,CAAC+E,gBAAhB;;QACA,IACExS,WAAW,KAAK,YAAhB,KACCsS,cAAc,IAAItS,WAAW,KAAK,SADnC,CADF,EAGE;UACAuS,uBAAuB,CAAC5N,IAAxB,CAA6B8I,eAAe,CAAC5M,OAAhB,EAA7B;QACD;;QAEDhE,KAAI,CAACuQ,QAAL,CAAcrP,OAAd,EAAuB;UAAM,OAAC;YAAEkS,OAAO,EAAE;UAAX,CAAD;QAAmB,CAAhD;;QACApT,KAAI,CAACuS,UAAL,CAAgBrR,OAAhB;MACD;IACF,CAfD;IAiBA,KAAK4E,gBAAL;IAEA,OAAOpE,OAAO,CAACuL,GAAR,CAAYyI,uBAAZ,CAAP;EACD,CAzBM;;EA2BA9F,sCAAP,UACE1O,OADF,EAEER,OAFF,EAGEG,QAHF,EAG0C;IAExC,KAAK+U,gBAAL,CACE1U,OADF,EAEE,KAAK2U,wBAAL,CAA8B3U,OAA9B,EAAuCR,OAAvC,EAAgDG,QAAhD,CAFF;IAIA,OAAO,KAAKkD,UAAL,CAAmB7C,OAAnB,EAA4BR,OAA5B,CAAP;EACD,CAVM;;EAYAkP,oCAAP,UACE1O,OADF,EAEER,OAFF,EAGEwU,QAHF,EAGyB;IAEvBpR;IAEA,KAAK8R,gBAAL,CAAsB1U,OAAtB,EAA+BgU,QAA/B;IAEA,KAAKnR,UAAL,CAAmB7C,OAAnB,EAA4BR,OAA5B,EAGG8G,KAHH,CAGS;MAAM;IAAS,CAHxB;IAKA,OAAOtG,OAAP;EACD,CAfM;;EAiBA0O,kDAAP,UAAyC/P,EAAzC,EAIsB;IAJtB;;QACEyB;QACA6B;QACAlC;IAEAK,KAAK,GAAG,KAAK4F,SAAL,CAAe5F,KAAf,EAAsBsD,QAA9B;IACA3D,SAAS,GAAG,KAAKuP,YAAL,CAAkBlP,KAAlB,EAAyBL,SAAzB,CAAZ;;IAEA,IAAM6U,cAAc,GAAG,UAAC7U,SAAD,EAA8B;MACnD,YAAI,CAACoQ,qBAAL,CACE/P,KADF,EAEE,EAFF,EAGEL,SAHF,EAIE,KAJF,EAKEkM,GALF,CAKM,kBAAM;QACV,IAAI,CAAChK,WAAD,IAAgBA,WAAW,KAAK,UAApC,EAAgD;UAC9CnD,KAAI,CAAC4F,SAAL,CAAemQ,sBAAf,CACEjU,MADF,EAEER,KAFF,EAGEL,SAHF;;UAKAjB,KAAI,CAAC8F,gBAAL;QACD;;QAED,IAAIwL,qBAAqB,CAACxP,MAAD,CAAzB,EAAmC;UACjC,MAAM,IAAI5B,WAAJ,CAAgB;YACpBX,aAAa,EAAEuC,MAAM,CAACwB;UADF,CAAhB,CAAN;QAGD;;QAED,OAAOxB,MAAP;MACD,CAtBD;IAsBE,CAvBJ;;IAyBA,IAAI,KAAKoF,SAAL,CAAe5F,KAAf,EAAsB6F,gBAA1B,EAA4C;MAC1C,IAAM6O,mBAAiB,GAAG,KAAKzG,UAAL,CAAgBlI,oBAAhB,CACxB/F,KADwB,EAExBL,SAFwB,EAGxBqD,IAHwB,CAGnBwR,cAHmB,CAA1B;MAKA,OAAO,IAAIpX,UAAJ,CAA+B,oBAAQ;QAC5C,IAAI4P,GAAG,GAAwB,IAA/B;QACA0H,mBAAiB,CAAC1R,IAAlB,CACE,sBAAU;UAAI,UAAG,GAAGmK,UAAU,CAAClM,SAAX,CAAqB1B,QAArB,CAAN;QAAoC,CADpD,EAEEA,QAAQ,CAACyB,KAFX;QAIA,OAAO;UAAM,UAAG,IAAIgM,GAAG,CAACjM,WAAJ,EAAP;QAAwB,CAArC;MACD,CAPM,CAAP;IAQD;;IAED,OAAOyT,cAAc,CAAC7U,SAAD,CAArB;EACD,CAlDM;;EAoDA2O,mCAAP,UAAiB1O,OAAjB,EAAgC;IAC9B,KAAK6O,oBAAL,CAA0B7O,OAA1B;IACA,KAAK4E,gBAAL;EACD,CAHM;;EAKC8J,8CAAR,UAA6B1O,OAA7B,EAA4C;IAC1C,KAAK+T,2BAAL,CAAiC/T,OAAjC;IACA,KAAKgB,WAAL,CAAiBhB,OAAjB;EACD,CAHO;;EAKD0O,qCAAP,UAAmB1O,OAAnB,EAAkC;IAMhC,KAAK8O,mBAAL,CAAyBhO,MAAzB,CAAgC,WAASd,OAAzC;IACA,KAAK8O,mBAAL,CAAyBhO,MAAzB,CAAgC,kBAAgBd,OAAhD;IACA,KAAK6R,QAAL,CAAc7R,OAAd,EAAuB8D,aAAvB,CAAqCxF,OAArC,CAA6C,aAAC;MAAI,QAAC,CAAC6C,WAAF;IAAe,CAAjE;IACA,KAAKwN,OAAL,CAAa7N,MAAb,CAAoBd,OAApB;EACD,CAVM;;EAYA0O,+CAAP,UACEgB,eADF,EAEErF,UAFF,EAE4B;IAA1B;MAAAA;IAA0B;;IAKpB;IAAA,IAAEtK,wBAAF;IAAA,IAAaK,gBAAb;IAAA,IAAoB6B,4BAApB;IAAA,IAAiCmI,wCAAjC;IACN,IAAM1I,UAAU,GAAGgO,eAAe,CAAC0C,aAAhB,EAAnB;IACQ;;IAER,IAAIF,OAAO,IAAIA,OAAO,CAAC7E,QAAvB,EAAiC;MAC/B,OAAO;QAAE9L,IAAI,EAAE2Q,OAAO,CAACtR,MAAhB;QAAwBgB,OAAO,EAAE;MAAjC,CAAP;IACD;;IAED,IAAIK,WAAW,KAAK,UAAhB,IAA8BA,WAAW,KAAK,cAAlD,EAAkE;MAChE,OAAO;QAAEV,IAAI,EAAEC,SAAR;QAAmBI,OAAO,EAAE;MAA5B,CAAP;IACD;;IAEK;kBAAA;0BAAA;8DAAA;6BAAA;;IAAA;IAAA,IAAEhB,kBAAF;IAAA,IAAUyM,sBAAV;;IAQN,OAAO;MACL9L,IAAI,EAAG8L,QAAQ,IAAIjD,iBAAb,GAAkCxJ,MAAlC,GAA2C,KAAK,CADjD;MAELgB,OAAO,EAAE,CAACyL;IAFL,CAAP;EAID,CA/BM;;EAiCAqB,oDAAP,UACEqG,mBADF,EACkE;IAMhE,IAAIrF,eAAJ;;IACA,IAAI,OAAOqF,mBAAP,KAA+B,QAAnC,EAA6C;MACnC;MAGRnS;MAIA8M,eAAe,GAAGsF,qBAAlB;IACD,CATD,MASO;MACLtF,eAAe,GAAGqF,mBAAlB;IACD;;IAEK;IAAA,IAAEhV,wBAAF;IAAA,IAAaK,gBAAb;IACN,OAAO;MACLkD,cAAc,EAAE,KAAK2R,qBAAL,CAA2BvF,eAA3B,EAA4C,KAA5C,EAAmDnO,IAD9D;MAELxB,SAAS,WAFJ;MAGL2D,QAAQ,EAAEtD;IAHL,CAAP;EAKD,CA3BM;;EA6BAsO,0CAAP;IAAA;;IACE,KAAKV,WAAL;IACA,KAAKW,OAAL,CAAarQ,OAAb,CAAqB,UAAC4W,IAAD,EAAOC,EAAP,EAAS;MAC5B,IAAID,IAAI,CAAC9D,WAAT,EAAsB;QACpB8D,IAAI,CAACjB,SAAL,CAAe3V,OAAf,CAAuB,oBAAQ;UAG7B,IAAI0V,QAAJ,EAAc;YACZA,QAAQ,CAAClV,KAAI,CAACgD,UAAL,CAAgBC,GAAhB,CAAoBoT,EAApB,CAAD,EAA0BD,IAAI,CAAChD,OAA/B,CAAR;UACD;QACF,CAND;MAOD;IACF,CAVD;EAWD,CAbM;;EAeAxD,uCAAP;IACE,OAAO,KAAKL,UAAZ;EACD,CAFM;;EASCK,+CAAR,UACEtO,KADF,EAEEsI,OAFF,EAGE3I,SAHF,EAIEqV,aAJF,EAIkD;IAJlD;;IAIE;MAAAA,gBAAyB,KAAKtH,kBAA9B;IAAgD;;IAEhD,IAAIP,UAAJ;IAEQ;;IACR,IAAIlH,WAAJ,EAAiB;MACT;MAAA,IAAEgP,sDAAF;MAAA,IAA2BxH,cAA3B;;MAEN,IAAM/C,SAAS,GAAG;QAChB1K,KAAK,EAAEiG,WADS;QAEhBtG,SAAS,WAFO;QAGhBuV,aAAa,EAAEC,gBAAgB,CAAClP,WAAD,CAAhB,IAAiC,KAAK,CAHrC;QAIhBqC,OAAO,EAAE,KAAKY,cAAL,CAAmBnH,sBACvBuG,OADuB,GAChB;UACV8M,UAAU,EAAE,CAACJ;QADH,CADgB,CAAnB;MAJO,CAAlB;MAUA1M,OAAO,GAAGoC,SAAS,CAACpC,OAApB;;MAEA,IAAI0M,aAAJ,EAAmB;QACjB,IAAMK,aAAW,GAAGJ,yBAAuB,CAACtT,GAAxB,CAA4BsE,WAA5B,KAA4C,IAAIiI,GAAJ,EAAhE;QACA+G,yBAAuB,CAAC3B,GAAxB,CAA4BrN,WAA5B,EAAyCoP,aAAzC;QAEA,IAAMC,SAAO,GAAGC,IAAI,CAACC,SAAL,CAAe7V,SAAf,CAAhB;QACAwN,UAAU,GAAGkI,aAAW,CAAC1T,GAAZ,CAAgB2T,SAAhB,CAAb;;QAEA,IAAI,CAACnI,UAAL,EAAiB;UACfkI,aAAW,CAAC/B,GAAZ,CACEgC,SADF,EAEEnI,UAAU,GAAGL,SAAS,CACpB9B,OAAO,CAACyC,IAAD,EAAO/C,SAAP,CADa,CAFxB;;UAOA,IAAM+K,OAAO,GAAG;YACdJ,aAAW,CAAC3U,MAAZ,CAAmB4U,SAAnB;YACA,IAAI,CAACD,aAAW,CAAC1U,IAAjB,EAAuBsU,yBAAuB,CAACvU,MAAxB,CAA+BuF,WAA/B;YACvByP,YAAU,CAAC3U,WAAX;UACD,CAJD;;UAMA,IAAM2U,YAAU,GAAGvI,UAAU,CAAClM,SAAX,CAAqB;YACtCV,IAAI,EAAEkV,OADgC;YAEtCzU,KAAK,EAAEyU,OAF+B;YAGtCxI,QAAQ,EAAEwI;UAH4B,CAArB,CAAnB;QAKD;MAEF,CA5BD,MA4BO;QACLtI,UAAU,GAAGL,SAAS,CAAC9B,OAAO,CAACyC,IAAD,EAAO/C,SAAP,CAAR,CAAtB;MACD;IACF,CA9CD,MA8CO;MACLyC,UAAU,GAAG/P,UAAU,CAACuY,EAAX,CAAc;QAAExU,IAAI,EAAE;MAAR,CAAd,CAAb;MACAmH,OAAO,GAAG,KAAKY,cAAL,CAAoBZ,OAApB,CAAV;IACD;;IAEO;;IACR,IAAI2K,WAAJ,EAAiB;MACf9F,UAAU,GAAGD,QAAQ,CAACC,UAAD,EAAa,kBAAM;QACtC,OAAOzO,KAAI,CAACuP,UAAL,CAAgB2D,YAAhB,CAA6B;UAClCtO,QAAQ,EAAE2P,WADwB;UAElC5K,YAAY,EAAE7H,MAFoB;UAGlC8H,OAAO,SAH2B;UAIlC3I,SAAS;QAJyB,CAA7B,CAAP;MAMD,CAPoB,CAArB;IAQD;;IAED,OAAOwN,UAAP;EACD,CAzEO;;EA8EAmB,sCAAR,UAAwB/P,EAAxB,EAYC;IAZD;;QACEoS;QACA/Q;QACA0D;QACAlE;QACAgI;IAQQ;IAAA,IAAW/H,wBAAX;IAAA,IAAWyC,yCAAX;IAAA,IAAiCD,iCAAjC;IACR,IAAI4Q,eAAJ;IACA,IAAImD,eAAJ;IAEA,OAAO,IAAIxV,OAAJ,CAAkC,UAACC,OAAD,EAAUC,MAAV,EAAgB;MACvD,IAAM6M,UAAU,GAAGzO,KAAI,CAACqR,qBAAL,CACjBzM,QADiB,EAEjBlE,OAAO,CAACkJ,OAFS,EAGjB3I,SAHiB,CAAnB;;MAMA,IAAMkW,MAAM,GAAG,kBAAgBjW,OAA/B;;MACAlB,KAAI,CAACgQ,mBAAL,CAAyB4E,GAAzB,CAA6BuC,MAA7B,EAAqCvV,MAArC;;MAEA,IAAMmV,OAAO,GAAG;QACd/W,KAAI,CAACgQ,mBAAL,CAAyBhO,MAAzB,CAAgCmV,MAAhC;;QACAnX,KAAI,CAACuQ,QAAL,CAAcrP,OAAd,EAAuB,UAACrB,EAAD,EAAkB;cAAfmF;UACxBA,aAAa,CAAChD,MAAd,CAAqBI,YAArB;QACD,CAFD;MAGD,CALD;;MAOA,IAAMA,YAAY,GAAGqM,UAAU,CAACtB,GAAX,CAAe,UAACrL,MAAD,EAAuB;QACzD,IAAImQ,SAAS,IAAIjS,KAAI,CAAC+S,QAAL,CAAc7R,OAAd,EAAuBmR,aAAxC,EAAuD;UACrDrS,KAAI,CAACmT,eAAL,CACEjS,OADF,EAEEY,MAFF,EAGEpB,OAHF,EAIEgI,mBAJF;;UAOA1I,KAAI,CAACgD,UAAL,CAAgBmQ,eAAhB,CACEjS,OADF,EAEEY,MAFF,EAGE4G,mBAHF;;UAMA1I,KAAI,CAACuS,UAAL,CAAgBrR,OAAhB;;UACAlB,KAAI,CAACuS,UAAL,CAAgB7J,mBAAhB;;UAEA1I,KAAI,CAAC8F,gBAAL;QACD;;QAED,IAAI1C,WAAW,KAAK,MAAhB,IAA0BvE,eAAe,CAACiD,MAAM,CAACwB,MAAR,CAA7C,EAA8D;UAC5D,OAAO1B,MAAM,CAAC,IAAI1B,WAAJ,CAAgB;YAC5BX,aAAa,EAAEuC,MAAM,CAACwB;UADM,CAAhB,CAAD,CAAb;QAGD;;QAED,IAAIF,WAAW,KAAK,KAApB,EAA2B;UACzB8T,eAAe,GAAGpV,MAAM,CAACwB,MAAzB;QACD;;QAED,IAAIoF,mBAAmB,IAAIvF,WAAW,KAAK,UAA3C,EAAuD;UAGrD4Q,eAAe,GAAGjS,MAAM,CAACW,IAAzB;QACD,CAJD,MAIO;UAEC;gCAAA;2BAAA;6BAAA;;UAAA;UAAA,IAAE2U,oBAAF;UAAA,IAAU7I,sBAAV;;UAON,IAAIA,QAAQ,IAAI7N,OAAO,CAAC4K,iBAAxB,EAA2C;YACzCyI,eAAe,GAAGqD,QAAlB;UACD;QACF;MACF,CAhDoB,EAgDlB7U,SAhDkB,CAgDR;QACXD,KAAK,EAAL,UAAMA,KAAN,EAAwB;UACtByU,OAAO;UACPnV,MAAM,CAACU,KAAD,CAAN;QACD,CAJU;QAMXiM,QAAQ;UACNwI,OAAO;UACPpV,OAAO,CAAC;YACNc,IAAI,EAAEsR,eADA;YAENzQ,MAAM,EAAE4T,eAFF;YAGNrU,OAAO,EAAE,KAHH;YAINrE,aAAa,EAAEF,aAAa,CAACiF,KAJvB;YAKNE,KAAK,EAAE;UALD,CAAD,CAAP;QAOD;MAfU,CAhDQ,CAArB;;MAkEAzD,KAAI,CAACuQ,QAAL,CAAcrP,OAAd,EAAuB,UAACrB,EAAD,EAAkB;YAAfmF;QACxBA,aAAa,CAACC,GAAd,CAAkB7C,YAAlB;MACD,CAFD;IAGD,CAtFM,CAAP;EAuFD,CAxGO;;EA0GAwN,kCAAR,UAAiB1O,OAAjB,EAAgC;IAC9B,OACE,KAAK2O,OAAL,CAAa5M,GAAb,CAAiB/B,OAAjB,KAA6B;MAC3BiU,SAAS,EAAE,IAAIpU,GAAJ,EADgB;MAE3BuR,WAAW,EAAE,KAFc;MAG3B1N,QAAQ,EAAE,IAHiB;MAI3BwO,OAAO,EAAE,IAJkB;MAK3Bf,aAAa,EAAE,CALY;MAM3BzB,eAAe,EAAE,IANU;MAO3B5L,aAAa,EAAE,IAAIjE,GAAJ;IAPY,CAD/B;EAWD,CAZO;;EAcA6O,kCAAR,UACE1O,OADF,EAEE2P,OAFF,EAEyD;IAEvD,IAAMwG,IAAI,GAAG,KAAKtE,QAAL,CAAc7R,OAAd,CAAb;;IACA,IAAMoW,OAAO,yBAAQD,IAAR,GAAiBxG,OAAO,CAACwG,IAAD,CAAxB,CAAb;;IACA,KAAKxH,OAAL,CAAa+E,GAAb,CAAiB1T,OAAjB,EAA0BoW,OAA1B;EACD,CAPO;;EASA1H,oCAAR,UACE1O,OADF,EAEEoR,WAFF,EAEoB;IAAlB;MAAAA;IAAkB;;IAElB,IAAIpR,OAAJ,EAAa;MACX,KAAKqP,QAAL,CAAcrP,OAAd,EAAuB;QAAM,OAAC;UAAEoR,WAAW;QAAb,CAAD;MAAiB,CAA9C;IACD;EACF,CAPO;;EASA1C,wCAAR,UAAuBhG,OAAvB,EAAmC;IAAZ;MAAAA;IAAY;;IACjC,IAAMM,UAAU,GAAG,KAAKqF,UAAL,CAAgB/E,cAAhB,CAA+BZ,OAA/B,CAAnB;IACA,6BACKM,UADL,GACe;MACboF,eAAe,EAAE,KAAKA;IADT,CADf;EAID,CANO;;EAQDM,uCAAP,UAAqB1O,OAArB,EAAoC;IAClC,IAAMI,KAAK,GAAG,KAAK0B,UAAL,CAAgBC,GAAhB,CAAoB/B,OAApB,CAAd;IAEA,OACEI,KAAK,IACLA,KAAK,CAAC9C,aAAN,KAAwBF,aAAa,CAACiF,KADtC,IAEAjC,KAAK,CAAC9C,aAAN,KAAwBF,aAAa,CAACgE,KAHxC;EAKD,CARM;;EAiBAsN,2CAAP,UACElP,OADF,EAEEQ,OAFF,EAGEgU,QAHF,EAG0B;IAH1B;;IAKU;IAERpR;;IAMA,IAAI,CAAC,KAAKsL,OAAV,EAAmB;MACjB,IAAIgH,IAAI,GAAG,KAAKmB,oBAAL,CAA0BtU,GAA1B,CAA8B/B,OAA9B,CAAX;;MACA,IAAI,CAACkV,IAAL,EAAW;QACT,KAAKmB,oBAAL,CAA0B3C,GAA1B,CAA8B1T,OAA9B,EAAwCkV,IAAI,GAAG,EAA/C;MACD;;MAEDA,IAAI,CAACoB,QAAL,GAAgBrS,YAAhB;MACAiR,IAAI,CAAC1V,OAAL,GAAY2C,sBACP3C,OADO,GACA;QACVyC,WAAW,EAAE;MADH,CADA,CAAZ;;MAKA,IAAMsU,YAAU,GAAG;QACjB,IAAMrB,IAAI,GAAGpW,KAAI,CAACuX,oBAAL,CAA0BtU,GAA1B,CAA8B/B,OAA9B,CAAb;;QACA,IAAIkV,IAAJ,EAAU;UACR,IAAIpW,KAAI,CAAC0X,aAAL,CAAmBxW,OAAnB,CAAJ,EAAiC;YAC/ByW,MAAI;UACL,CAFD,MAEO;YACL3X,KAAI,CAAC+D,UAAL,CAAgB7C,OAAhB,EAAyBkV,IAAI,CAAC1V,OAA9B,EAAuCL,SAAS,CAACsS,IAAjD,EAAuDrO,IAAvD,CACEqT,MADF,EAEEA,MAFF;UAID;QACF;MACF,CAZD;;MAcA,IAAMA,MAAI,GAAG;QACX,IAAMvB,IAAI,GAAGpW,KAAI,CAACuX,oBAAL,CAA0BtU,GAA1B,CAA8B/B,OAA9B,CAAb;;QACA,IAAIkV,IAAJ,EAAU;UACRwB,YAAY,CAACxB,IAAI,CAACyB,OAAN,CAAZ;UACAzB,IAAI,CAACyB,OAAL,GAAe1V,UAAU,CAACsV,YAAD,EAAarB,IAAI,CAACoB,QAAlB,CAAzB;QACD;MACF,CAND;;MAQA,IAAItC,QAAJ,EAAc;QACZ,KAAKU,gBAAL,CAAsB1U,OAAtB,EAA+BgU,QAA/B;MACD;;MAEDyC,MAAI;IACL;;IAED,OAAOzW,OAAP;EACD,CAvDM;;EAyDA0O,0CAAP,UAAwB1O,OAAxB,EAAuC;IACrC,KAAKqW,oBAAL,CAA0BvV,MAA1B,CAAiCd,OAAjC;EACD,CAFM;;EAGT;AAAC,CAt0CD;;ACjCA;EAGE,mBAAY4W,YAAZ,EAAkD;IAChD,KAAK5O,KAAL,GAAa4O,YAAb;EACD;;EAEMC,+BAAP;IACE,OAAO,KAAK7O,KAAZ;EACD,CAFM;;EAIA6O,sCAAP,UACEjW,MADF,EAEE8C,QAFF,EAGE3D,SAHF,EAIEyH,mBAJF,EAKEsP,YALF,EAK+B;IAA7B;MAAAA;IAA6B;;IAE7B,IAAIC,eAAe,GAAG,CAAC3G,qBAAqB,CAACxP,MAAD,CAA5C;;IACA,IAAIkW,YAAY,IAAI1G,qBAAqB,CAACxP,MAAD,CAArC,IAAiDA,MAAM,CAACW,IAA5D,EAAkE;MAChEwV,eAAe,GAAG,IAAlB;IACD;;IACD,IAAI,CAACvP,mBAAD,IAAwBuP,eAA5B,EAA6C;MAC3C,KAAK/O,KAAL,CAAWgP,KAAX,CAAiB;QACfpW,MAAM,EAAEA,MAAM,CAACW,IADA;QAEf0V,MAAM,EAAE,YAFO;QAGf7W,KAAK,EAAEsD,QAHQ;QAIf3D,SAAS,EAAEA;MAJI,CAAjB;IAMD;EACF,CAnBM;;EAqBA8W,6CAAP,UACEjW,MADF,EAEE8C,QAFF,EAGE3D,SAHF,EAGgB;IAId,IAAI,CAACqQ,qBAAqB,CAACxP,MAAD,CAA1B,EAAoC;MAClC,KAAKoH,KAAL,CAAWgP,KAAX,CAAiB;QACfpW,MAAM,EAAEA,MAAM,CAACW,IADA;QAEf0V,MAAM,EAAE,mBAFO;QAGf7W,KAAK,EAAEsD,QAHQ;QAIf3D,SAAS,EAAEA;MAJI,CAAjB;IAMD;EACF,CAfM;;EAiBA8W,uCAAP,UAAwB3P,QAAxB,EAOC;IAPD;;IAQE,IAAIA,QAAQ,CAAC8H,kBAAb,EAAiC;MAC/B,IAAIkI,YAAJ;;MACA,IAAI,OAAOhQ,QAAQ,CAAC8H,kBAAhB,KAAuC,UAA3C,EAAuD;QACrDkI,YAAU,GAAGhQ,QAAQ,CAAC8H,kBAAT,CAA4B9H,QAAQ,CAACnH,SAArC,CAAb;MACD,CAFD,MAEO;QACLmX,YAAU,GAAGhQ,QAAQ,CAAC8H,kBAAtB;MACD;;MAED,KAAKhH,KAAL,CAAWmP,2BAAX,CAAuC,aAAC;QACtC,IAAMC,IAAI,GAAGtY,KAAI,CAACkJ,KAAlB;QACAlJ,KAAI,CAACkJ,KAAL,GAAaqP,CAAb;;QAEA,IAAI;UACFvY,KAAI,CAACuR,kBAAL,CAAwB;YACtBpJ,UAAU,EAAEC,QAAQ,CAACD,UADC;YAEtBrG,MAAM,EAAE;cAAEW,IAAI,EAAE2V;YAAR,CAFc;YAGtBxT,QAAQ,EAAEwD,QAAQ,CAACxD,QAHG;YAItB3D,SAAS,EAAEmH,QAAQ,CAACnH,SAJE;YAKtBgQ,aAAa,EAAE7I,QAAQ,CAAC6I,aALF;YAMtBC,MAAM,EAAE9I,QAAQ,CAAC8I;UANK,CAAxB;QAQD,CATD,SASU;UACRlR,KAAI,CAACkJ,KAAL,GAAaoP,IAAb;QACD;MACF,CAhBD,EAgBGlQ,QAAQ,CAACD,UAhBZ;IAiBD;EACF,CAlCM;;EAoCA4P,yCAAP,UAA0B3P,QAA1B,EAOC;IAPD;;IASE,IAAI,CAACkJ,qBAAqB,CAAClJ,QAAQ,CAACtG,MAAV,CAA1B,EAA6C;MAC3C,IAAM0W,aAAW,GAAyB,CAAC;QACzC1W,MAAM,EAAEsG,QAAQ,CAACtG,MAAT,CAAgBW,IADiB;QAEzC0V,MAAM,EAAE,eAFiC;QAGzC7W,KAAK,EAAE8G,QAAQ,CAACxD,QAHyB;QAIzC3D,SAAS,EAAEmH,QAAQ,CAACnH;MAJqB,CAAD,CAA1C;MAOQ;;MACR,IAAIwX,eAAJ,EAAmB;QACjBC,MAAM,CAACC,IAAP,CAAYF,eAAZ,EAA2BjZ,OAA3B,CAAmC,cAAE;UAC7B;UAAA,IAAE8B,gBAAF;UAAA,IAASuP,oBAAT;;UAGA;iCAAA;sCAAA;mCAAA;;UAAA;UAAA,IAAE+H,8BAAF;UAAA,IAA8BrK,sBAA9B;;UAON,IAAIA,QAAJ,EAAc;YAEZ,IAAMsK,eAAe,GAAGlT,qBAAqB,CAAC;cAC5C,cAAO,CAACiT,kBAAD,EAAqB;gBAC1BE,cAAc,EAAE1Q,QAAQ,CAACtG,MADC;gBAE1BP,SAAS,EAAEkV,gBAAgB,CAACnV,KAAK,CAACsD,QAAP,CAAhB,IAAoClC,SAFrB;gBAG1BqW,cAAc,EAAEzX,KAAK,CAACL;cAHI,CAArB,CAAP;YAIE,CALyC,CAA7C;;YASA,IAAI4X,eAAJ,EAAqB;cACnBL,aAAW,CAAC1Q,IAAZ,CAAiB;gBACfhG,MAAM,EAAE+W,eADO;gBAEfV,MAAM,EAAE,YAFO;gBAGf7W,KAAK,EAAEA,KAAK,CAACsD,QAHE;gBAIf3D,SAAS,EAAEK,KAAK,CAACL;cAJF,CAAjB;YAMD;UACF;QACF,CA/BD;MAgCD;;MAED,KAAKiI,KAAL,CAAW8P,kBAAX,CAA8B,aAAC;QAC7BR,aAAW,CAAChZ,OAAZ,CAAoB,iBAAK;UAAI,QAAC,CAAC0Y,KAAF,CAAQA,KAAR;QAAc,CAA3C;QAKQ;;QACR,IAAIhH,MAAJ,EAAY;UACVvL,qBAAqB,CAAC;YAAM,aAAM,CAAC4S,CAAD,EAAInQ,QAAQ,CAACtG,MAAb,CAAN;UAA0B,CAAjC,CAArB;QACD;MACF,CAVD;IAWD;EACF,CAjEM;;EAmEAiW,2CAAP,UAA4BlY,EAA5B,EAMC;QALCsI;QACA+H;;IAKA,IAAIA,kBAAJ,EAAwB;MACtB,KAAKhH,KAAL,CAAW+P,gBAAX,CAA4B9Q,UAA5B;IACD;EACF,CAVM;;EAYA4P,4CAAP,UACEnT,QADF,EAEE3D,SAFF,EAGEyC,SAHF,EAGgB;IAEd,KAAKwF,KAAL,CAAWgP,KAAX,CAAiB;MACfpW,MAAM,EAAE4B,SADO;MAEfyU,MAAM,EAAE,YAFO;MAGflX,SAAS,WAHM;MAIfK,KAAK,EAAEsD;IAJQ,CAAjB;EAMD,CAXM;;EAaAmT,4BAAP;IACE,OAAO,KAAK7O,KAAL,CAAWN,KAAX,EAAP;EACD,CAFM;;EAGT;AAAC,CApLD;;ACxBO,IAAMsQ,OAAO,GAAG,QAAhB;ACuCP,IAAIC,oBAAoB,GAAG,KAA3B;;AAwBA;EAkDE,sBAAYzY,OAAZ,EAAqD;IAArD;;IA1CO,sBAAiC,EAAjC;IAIC,2BAAiD,EAAjD;IACA,2BAAiD,EAAjD;IAuCJ;IAAA,IACAb,oBADA;IAAA,IACAuP,oCADA;IAAA,IAEAzO,+BAFA;IAAA,IAEAyY,2CAFA;IAAA,IAGAC,6CAHA;IAAA,IAIApK,+BAJA;IAAA,IAIAD,8CAJA;IAAA,IAKAsK,uCALA;IAAA,IAMAnK,mCANA;IAAA,IAMAjJ,mDANA;IAAA,IAOAkD,6BAPA;IAAA,IAQAmQ,2BARA;IAAA,IASAlQ,yCATA;IAAA,IAUAmQ,kCAVA;IAAA,IAWAC,wCAXA;IAcI;;IAIN,IAAI,CAAC1K,IAAD,IAAS3F,SAAb,EAAwB;MACtB2F,IAAI,GAAG2K,UAAU,CAACC,KAAX,EAAP;IACD;;IAED,IAAI,CAAC5K,IAAD,IAAS,CAAC7F,KAAd,EAAqB;MACnB,MAAMpF,qMAEJ,kHAFI,GAGJ,iHAHI,CAAN;IAKD;;IAGD,KAAKiL,IAAL,GAAYA,IAAZ;IACA,KAAK7F,KAAL,GAAaA,KAAb;IACA,KAAKhB,KAAL,GAAa,IAAI6P,SAAJ,CAAc7O,KAAd,CAAb;IACA,KAAK0Q,qBAAL,GAA6BxK,OAAO,IAAIgK,kBAAkB,GAAG,CAA7D;IACA,KAAKpK,kBAAL,GAA0BA,kBAA1B;IACA,KAAKsK,cAAL,GAAsBA,cAAc,IAAI,EAAxC;IACA,KAAKC,QAAL,GAAgBA,QAAhB;;IAEA,IAAIH,kBAAJ,EAAwB;MACtBjX,UAAU,CACR;QAAM,OAACnC,KAAI,CAAC4Z,qBAAL,GAA6B,KAA9B;MAAoC,CADlC,EAERR,kBAFQ,CAAV;IAID;;IAED,KAAKrE,UAAL,GAAkB,KAAKA,UAAL,CAAgB8E,IAAhB,CAAqB,IAArB,CAAlB;IACA,KAAKvY,KAAL,GAAa,KAAKA,KAAL,CAAWuY,IAAX,CAAgB,IAAhB,CAAb;IACA,KAAKC,MAAL,GAAc,KAAKA,MAAL,CAAYD,IAAZ,CAAiB,IAAjB,CAAd;IACA,KAAKE,UAAL,GAAkB,KAAKA,UAAL,CAAgBF,IAAhB,CAAqB,IAArB,CAAlB;IACA,KAAKrE,wBAAL,GAAgC,KAAKA,wBAAL,CAA8BqE,IAA9B,CAAmC,IAAnC,CAAhC;IAIA,IAAMG,wBAAwB,GAC5BlW,OAAO,CAACmW,GAAR,CAAY1R,QAAZ,KAAyB,YAAzB,IACA,OAAO2R,MAAP,KAAkB,WADlB,IAEA,CAAEA,MAAc,CAACC,iBAHnB;;IAKA,IACE,OAAOd,iBAAP,KAA6B,WAA7B,GACIW,wBADJ,GAEIX,iBAAiB,IAAI,OAAOa,MAAP,KAAkB,WAH7C,EAIE;MACCA,MAAc,CAACC,iBAAf,GAAmC,IAAnC;IACF;;IAKD,IAAI,CAAChB,oBAAD,IAAyBrV,OAAO,CAACmW,GAAR,CAAY1R,QAAZ,KAAyB,YAAtD,EAAoE;MAClE4Q,oBAAoB,GAAG,IAAvB;;MACA,IACE,OAAOe,MAAP,KAAkB,WAAlB,IACAA,MAAM,CAACtV,QADP,IAEAsV,MAAM,CAACE,GAAP,KAAeF,MAAM,CAAC/I,IAHxB,EAIE;QAEA,IACE,OAAQ+I,MAAc,CAACG,+BAAvB,KAA2D,WAD7D,EAEE;UAEA,IACEH,MAAM,CAACI,SAAP,IACAJ,MAAM,CAACI,SAAP,CAAiBC,SADjB,IAEAL,MAAM,CAACI,SAAP,CAAiBC,SAAjB,CAA2BC,OAA3B,CAAmC,QAAnC,IAA+C,CAAC,CAHlD,EAIE;YAEAC,OAAO,CAACC,KAAR,CACE,kCACE,uCADF,GAEE,sGAHJ;UAKD;QACF;MACF;IACF;;IAED,KAAKxB,OAAL,GAAeA,OAAf;IAEA,KAAK3J,UAAL,GAAkB,IAAI/F,UAAJ,CAAe;MAC/BN,KAAK,OAD0B;MAE/BC,MAAM,EAAE,IAFuB;MAG/BC,SAAS,WAHsB;MAI/BC,eAAe;IAJgB,CAAf,CAAlB;IAOA,KAAK5I,YAAL,GAAoB,IAAImP,YAAJ,CAAiB;MACnCb,IAAI,EAAE,KAAKA,IADwB;MAEnC7G,KAAK,EAAE,KAAKA,KAFuB;MAGnC8G,kBAAkB,oBAHiB;MAInCI,OAAO,SAJ4B;MAKnCE,eAAe,EAAE;QACf9N,IAAI,EAAEgY,mBADS;QAEfN,OAAO,EAAEO;MAFM,CALkB;MASnClK,UAAU,EAAE,KAAKA,UATkB;MAUnCrJ,sBAAsB,wBAVa;MAWnCgJ,WAAW,EAAE;QACX,IAAIlP,KAAI,CAAC2a,cAAT,EAAyB;UACvB3a,KAAI,CAAC2a,cAAL,CAAoB;YAClBC,MAAM,EAAE,EADU;YAElBC,KAAK,EAAE;cACLhL,OAAO,EAAE7P,KAAI,CAACS,YAAL,CAAkBuC,UAAlB,CAA6B8X,QAA7B,EADJ;cAELC,SAAS,EAAE/a,KAAI,CAACS,YAAL,CAAkBqQ,aAAlB,CAAgCgK,QAAhC;YAFN,CAFW;YAMlBE,yBAAyB,EAAEhb,KAAI,CAACkJ,KAAL,CAAW+R,OAAX,CAAmB,IAAnB;UANT,CAApB;QAQD;MACF;IAtBkC,CAAjB,CAApB;EAwBD;;EAMMC,8BAAP;IACE,KAAKza,YAAL,CAAkB0a,IAAlB;EACD,CAFM;;EAuBAD,oCAAP,UACExa,OADF,EACwC;IAEtC,IAAI,KAAK4Y,cAAL,CAAoBvE,UAAxB,EAAoC;MAClCrU,OAAO,GAAG2C,sBACL,KAAKiW,cAAL,CAAoBvE,UADf,GAELrU,OAFK,CAAV;IAID;;IAGD,IACE,KAAKkZ,qBAAL,KACClZ,OAAO,CAACyC,WAAR,KAAwB,cAAxB,IACCzC,OAAO,CAACyC,WAAR,KAAwB,mBAF1B,CADF,EAIE;MACAzC,OAAO,yBAAQA,OAAR,GAAe;QAAEyC,WAAW,EAAE;MAAf,CAAf,CAAP;IACD;;IAED,OAAO,KAAK1C,YAAL,CAAkBsU,UAAlB,CAA4CrU,OAA5C,CAAP;EACD,CApBM;;EA+BAwa,+BAAP,UACExa,OADF,EACmC;IAEjC,IAAI,KAAK4Y,cAAL,CAAoBhY,KAAxB,EAA+B;MAC7BZ,OAAO,GAAG2C,sBAAK,KAAKiW,cAAL,CAAoBhY,KAAzB,GAAmCZ,OAAnC,CAAV;IAGD;;IAEDoD,2OAGE,6EAHF,GAIE,0EAJF,GAKE,qEALF;;IAQA,IAAI,KAAK8V,qBAAL,IAA8BlZ,OAAO,CAACyC,WAAR,KAAwB,cAA1D,EAA0E;MACxEzC,OAAO,yBAAQA,OAAR,GAAe;QAAEyC,WAAW,EAAE;MAAf,CAAf,CAAP;IACD;;IAED,OAAO,KAAK1C,YAAL,CAAkBa,KAAlB,CAA2BZ,OAA3B,CAAP;EACD,CAtBM;;EA+BAwa,gCAAP,UACExa,OADF,EACyC;IAEvC,IAAI,KAAK4Y,cAAL,CAAoBQ,MAAxB,EAAgC;MAC9BpZ,OAAO,GAAG2C,sBACL,KAAKiW,cAAL,CAAoBQ,MADf,GAELpZ,OAFK,CAAV;IAID;;IAED,OAAO,KAAKD,YAAL,CAAkBqZ,MAAlB,CAA4BpZ,OAA5B,CAAP;EACD,CAXM;;EAiBAwa,mCAAP,UACExa,OADF,EAC0C;IAExC,OAAO,KAAKD,YAAL,CAAkBkE,wBAAlB,CAA8CjE,OAA9C,CAAP;EACD,CAJM;;EAeAwa,mCAAP,UACExa,OADF,EAEE6K,UAFF,EAE6B;IAA3B;MAAAA;IAA2B;;IAE3B,OAAO,KAAKrC,KAAL,CAAWkS,SAAX,CAAoC1a,OAApC,EAA6C6K,UAA7C,CAAP;EACD,CALM;;EAqBA2P,sCAAP,UACExa,OADF,EAEE6K,UAFF,EAE6B;IAA3B;MAAAA;IAA2B;;IAE3B,OAAO,KAAKrC,KAAL,CAAWmS,YAAX,CAAuC3a,OAAvC,EAAgD6K,UAAhD,CAAP;EACD,CALM;;EAYA2P,oCAAP,UACExa,OADF,EACyD;IAEvD,IAAMoB,MAAM,GAAG,KAAKoH,KAAL,CAAWoS,UAAX,CAAyC5a,OAAzC,CAAf;IACA,KAAKD,YAAL,CAAkBqF,gBAAlB;IACA,OAAOhE,MAAP;EACD,CANM;;EAmBAoZ,uCAAP,UACExa,OADF,EAC4D;IAE1D,IAAMoB,MAAM,GAAG,KAAKoH,KAAL,CAAWqS,aAAX,CAA4C7a,OAA5C,CAAf;IACA,KAAKD,YAAL,CAAkBqF,gBAAlB;IACA,OAAOhE,MAAP;EACD,CANM;;EAkBAoZ,mCAAP,UACExa,OADF,EAC4C;IAE1C,IAAMoB,MAAM,GAAG,KAAKoH,KAAL,CAAWsS,SAAX,CAA4B9a,OAA5B,CAAf;IACA,KAAKD,YAAL,CAAkBqF,gBAAlB;IACA,OAAOhE,MAAP;EACD,CANM;;EAQAoZ,iDAAP,UAA+BO,EAA/B,EAA4C;IAC1C,KAAKd,cAAL,GAAsBc,EAAtB;EACD,CAFM;;EAIAP,sCAAP,UAAoBQ,OAApB,EAA2C;IACzC,OAAOpP,OAAO,CAAC,KAAKyC,IAAN,EAAY2M,OAAZ,CAAd;EACD,CAFM;;EAOAR,0CAAP;IACEpX,yHAEI,0DAFJ;IAIA,OAAO,KAAKrD,YAAZ;EACD,CANM;;EAwBAya,oCAAP;IAAA;;IACE,OAAOxZ,OAAO,CAACC,OAAR,GACJ2C,IADI,CACC;MAAM,YAAI,CAAC7D,YAAL,CAAkB8U,UAAlB;IAA8B,CADrC,EAEJjR,IAFI,CAEC;MAAM,cAAO,CAAC2I,GAAR,CAAYjN,KAAI,CAAC2b,mBAAL,CAAyBxO,GAAzB,CAA6B,cAAE;QAAI,SAAE,EAAF;MAAI,CAAvC,CAAZ;IAAqD,CAF5D,EAGJ7I,IAHI,CAGC;MAAM,YAAI,CAACkR,wBAAL;IAA+B,CAHtC,CAAP;EAID,CALM;;EAWA0F,oCAAP;IAAA;;IACE,OAAOxZ,OAAO,CAACC,OAAR,GACJ2C,IADI,CACC;MAAM,YAAI,CAAC7D,YAAL,CAAkB8U,UAAlB;IAA8B,CADrC,EAEJjR,IAFI,CAEC;MAAM,cAAO,CAAC2I,GAAR,CAAYjN,KAAI,CAAC4b,mBAAL,CAAyBzO,GAAzB,CAA6B,cAAE;QAAI,SAAE,EAAF;MAAI,CAAvC,CAAZ;IAAqD,CAF5D,CAAP;EAGD,CAJM;;EAWA+N,sCAAP,UAAoBO,EAApB,EAA0C;IAA1C;;IACE,KAAKE,mBAAL,CAAyB7T,IAAzB,CAA8B2T,EAA9B;IACA,OAAO;MACLzb,KAAI,CAAC2b,mBAAL,GAA2B3b,KAAI,CAAC2b,mBAAL,CAAyBE,MAAzB,CAAgC,aAAC;QAAI,QAAC,KAAKJ,EAAN;MAAQ,CAA7C,CAA3B;IACD,CAFD;EAGD,CALM;;EAYAP,sCAAP,UAAoBO,EAApB,EAA0C;IAA1C;;IACE,KAAKG,mBAAL,CAAyB9T,IAAzB,CAA8B2T,EAA9B;IACA,OAAO;MACLzb,KAAI,CAAC4b,mBAAL,GAA2B5b,KAAI,CAAC4b,mBAAL,CAAyBC,MAAzB,CAAgC,aAAC;QAAI,QAAC,KAAKJ,EAAN;MAAQ,CAA7C,CAA3B;IACD,CAFD;EAGD,CALM;;EAmBAP,kDAAP,UACEzF,cADF,EAC0B;IAExB,OAAO,KAAKhV,YAAL,CAAkB+U,wBAAlB,CAA2CC,cAA3C,CAAP;EACD,CAJM;;EASAyF,iCAAP,UAAe3P,UAAf,EAAmC;IACjC,OAAO,KAAKrC,KAAL,CAAW+R,OAAX,CAAmB1P,UAAnB,CAAP;EACD,CAFM;;EAWA2P,iCAAP,UAAeY,eAAf,EAA2C;IACzC,OAAO,KAAK5S,KAAL,CAAW6S,OAAX,CAAmBD,eAAnB,CAAP;EACD,CAFM;;EAOAZ,sCAAP,UAAoB9R,SAApB,EAAsD;IACpD,KAAKmG,UAAL,CAAgBjG,YAAhB,CAA6BF,SAA7B;EACD,CAFM;;EAOA8R,sCAAP,UAAoB9R,SAApB,EAAsD;IACpD,KAAKmG,UAAL,CAAgByM,YAAhB,CAA6B5S,SAA7B;EACD,CAFM;;EAOA8R,sCAAP;IACE,OAAO,KAAK3L,UAAL,CAAgB0M,YAAhB,EAAP;EACD,CAFM;;EAOAf,sDAAP,UAAoC7R,eAApC,EAAoE;IAClE,KAAKkG,UAAL,CAAgBhG,kBAAhB,CAAmCF,eAAnC;EACD,CAFM;;EAGT;AAAC,CA3gBD","names":["NetworkStatus","isNetworkRequestInFlight","networkStatus","__extends","Observable","$$observable","LinkObservable","isNonEmptyArray","value","Array","isArray","length","isApolloError","err","hasOwnProperty","generateErrorMessage","message","graphQLErrors","forEach","graphQLError","errorMessage","networkError","replace","_a","extraInfo","_super","_this","__proto__","ApolloError","prototype","Error","FetchType","hasError","storeValue","policy","queryManager","options","_b","shouldSubscribe","observer","onSubscribe","Set","isTornDown","variables","queryId","generateQueryId","opDef","getOperationDefinition","query","queryName","name","ObservableQuery","Promise","resolve","reject","next","result","observers","delete","size","removeQuery","setTimeout","subscription","unsubscribe","error","subscribe","getCurrentResult","data","undefined","lastError","lastResult","loading","partial","queryStoreValue","queryStore","get","isNetworkFetchPolicy","fetchPolicy","errorPolicy","__assign","errors","ready","updateLastResult","stale","newResult","snapshot","isEqual","lastResultSnapshot","process","fetchQuery","refetch","fetchMoreOptions","invariant","combinedOptions","qid","normal","then","updateQuery","previousResult","fetchMoreResult","stopQuery","startGraphQLSubscription","document","subscriptionData","previous","onError","subscriptions","add","opts","pollInterval","startPolling","stopPolling","setVariables","oldFetchPolicy","fetchResults","tryFetch","mapFn","tryFunctionOrLogError","dataStore","markUpdateQueryResult","broadcastQueries","stopPollingQuery","assertNotCacheFirstOrOnly","startPollingQuery","assumeImmutableResults","cloneDeep","subObserver","_subscription","_observer","defaultSubscriptionObserverErrorCallback","first","setUpQuery","tearDownQuery","addObservableQuery","iterateObserversSafely","observeQuery","isDifferentFromLastResult","previousResult_1","query_1","fetchPolicy_1","transform","hasClientExports","getLocalState","addExportedVariables","previousVariables","serverQuery","catch","clear","removeObservableQuery","method","argument","observersWithMethod","push","obs","obsQuery","MutationStore","store","mutationId","mutation","QueryStore","previousQuery","NODE_ENV","isSetVariables","metadata","fetchMoreForQueryId","markQueryResultClient","reset","capitalizeFirstLetter","str","charAt","toUpperCase","slice","cache","client","resolvers","fragmentMatcher","addResolvers","setFragmentMatcher","LocalState","mergeDeep","resolverGroup","remoteResult","context","onlyRunForcedResolvers","resolveDocument","localResult","hasDirectives","removeClientSetsFromDocument","newContext","getCacheKey","obj","config","dataIdFromObject","buildRootValueFromCache","prepareContext","exportedVariables","forceResolvers","visit","Directive","enter","node","arguments","some","arg","kind","BREAK","diff","buildQueryFromSelectionSet","returnPartialData","optimistic","rootValue","mainDefinition","getMainDefinition","fragments","getFragmentDefinitions","fragmentMap","createFragmentMap","definitionOperation","operation","defaultOperationType","execContext","resolveSelectionSet","selectionSet","resultsToMerge","execute","selection","shouldInclude","isField","resolveField","fieldResult","resultKeyNameFromField","isInlineFragment","fragment","typeCondition","fragmentResult","all","selections","map","mergeDeepArray","field","fieldName","aliasedFieldName","aliasUsed","defaultResult","resultPromise","shouldForceResolvers","resolverType","__typename","resolverMap","argumentsObjectFromField","directives","directive","resolveSubSelectedArray","item","multiplex","inner","sub","complete","asyncMap","observable","activeNextCount","completed","handler","call","e","link","queryDeduplication","_c","onBroadcast","_d","ssrMode","_e","clientAwareness","localState","Map","canUseWeakMap","WeakMap","getCache","QueryManager","queries","_info","stopQueryNoBroadcast","fetchQueryRejectFns","InvariantError","optimisticResponse","updateQueriesByName","refetchQueries","awaitRefetchQueries","updateWithProxyFn","setQuery","getVariables","_f","generateUpdateQueriesInfo","ret","observableQuery","updater","mutationStore","initMutation","markMutationInit","updateQueries","update","self","storeResult","getObservableFromLink","graphQLResultHasError","markMutationResult","markMutationError","markMutationComplete","refetchQueryPromises","refetchQuery","queryOptions","fetchType","isNetworkOnly","needToFetch","shouldFetch","requestId","idCounter","cancel","updateQueryWatch","lastRequestId","invalidated","invalidate","initQuery","storePreviousVariables","isPoll","poll","isRefetch","networkResult","fetchRequest","getQuery","markQueryError","hasForcedResolvers","runResolvers","markQueryResult","newData","invoke","getLastResult","networkStatusChanged","shouldNotifyIfLoading","notifyOnNetworkStatusChange","hasGraphQLErrors","isMissing","getLastError","errorStatusChanged","diffResult","resultFromStore","transformCache","has","transformed","transformDocument","forLink","removeConnectionDirectiveFromDocument","transformForLink","clientQuery","cacheEntry_1","defaultVars","getDefaultValues","doc","set","transformedOptions","watchedQuery","watchQuery","String","stopQueryInStoreNoBroadcast","listener","listeners","watch","callback","resetIds","clearStore","reFetchObservableQueries","includeStandby","observableQueryPromises","resetLastResults","addQueryListener","queryListenerForObserver","makeObservable","markSubscriptionResult","observablePromise_1","queryIdOrObservable","foundObserveableQuery","getCurrentQueryResult","info","id","deduplication","inFlightLinkObservables_1","operationName","getOperationName","forceFetch","byVariables_1","varJson_1","JSON","stringify","cleanup","cleanupSub_1","of","errorsFromStore","fqrfId","result_1","prev","newInfo","pollingInfoByQueryId","interval","maybeFetch_1","checkInFlight","poll_1","clearTimeout","timeout","initialCache","DataStore","ignoreErrors","writeWithErrors","write","dataId","optimistic_1","recordOptimisticTransaction","orig","c","cacheWrites_1","updateQueries_1","Object","keys","currentQueryResult","nextQueryResult","mutationResult","queryVariables","performTransaction","removeOptimistic","version","hasSuggestedDevtools","ssrForceFetchDelay","connectToDevTools","defaultOptions","typeDefs","clientAwarenessName","clientAwarenessVersion","ApolloLink","empty","disableNetworkFetches","bind","mutate","resetStore","defaultConnectToDevTools","env","window","__APOLLO_CLIENT__","top","__APOLLO_DEVTOOLS_GLOBAL_HOOK__","navigator","userAgent","indexOf","console","debug","devToolsHookCb","action","state","getStore","mutations","dataWithOptimisticResults","extract","ApolloClient","stop","readQuery","readFragment","writeQuery","writeFragment","writeData","cb","payload","resetStoreCallbacks","clearStoreCallbacks","filter","serializedState","restore","setResolvers","getResolvers"],"sources":["../src/core/networkStatus.ts","../src/util/Observable.ts","../src/util/arrays.ts","../src/errors/ApolloError.ts","../src/core/types.ts","../src/core/ObservableQuery.ts","../src/data/mutations.ts","../src/data/queries.ts","../src/util/capitalizeFirstLetter.ts","../src/core/LocalState.ts","../src/util/observables.ts","../src/core/QueryManager.ts","../src/data/store.ts","../src/version.ts","../src/ApolloClient.ts"],"sourcesContent":["/**\n * The current status of a querys execution in our system.\n */\nexport enum NetworkStatus {\n  /**\n   * The query has never been run before and the query is now currently running. A query will still\n   * have this network status even if a partial data result was returned from the cache, but a\n   * query was dispatched anyway.\n   */\n  loading = 1,\n\n  /**\n   * If `setVariables` was called and a query was fired because of that then the network status\n   * will be `setVariables` until the result of that query comes back.\n   */\n  setVariables = 2,\n\n  /**\n   * Indicates that `fetchMore` was called on this query and that the query created is currently in\n   * flight.\n   */\n  fetchMore = 3,\n\n  /**\n   * Similar to the `setVariables` network status. It means that `refetch` was called on a query\n   * and the refetch request is currently in flight.\n   */\n  refetch = 4,\n\n  /**\n   * Indicates that a polling query is currently in flight. So for example if you are polling a\n   * query every 10 seconds then the network status will switch to `poll` every 10 seconds whenever\n   * a poll request has been sent but not resolved.\n   */\n  poll = 6,\n\n  /**\n   * No request is in flight for this query, and no errors happened. Everything is OK.\n   */\n  ready = 7,\n\n  /**\n   * No request is in flight for this query, but one or more errors were detected.\n   */\n  error = 8,\n}\n\n/**\n * Returns true if there is currently a network request in flight according to a given network\n * status.\n */\nexport function isNetworkRequestInFlight(\n  networkStatus: NetworkStatus,\n): boolean {\n  return networkStatus < 7;\n}\n","// This simplified polyfill attempts to follow the ECMAScript Observable proposal.\n// See https://github.com/zenparsing/es-observable\nimport { Observable as LinkObservable } from 'apollo-link';\n\nexport type Subscription = ZenObservable.Subscription;\nexport type Observer<T> = ZenObservable.Observer<T>;\n\nimport $$observable from 'symbol-observable';\n\n// rxjs interopt\nexport class Observable<T> extends LinkObservable<T> {\n  public [$$observable]() {\n    return this;\n  }\n\n  public ['@@observable' as any]() {\n    return this;\n  }\n}\n","export function isNonEmptyArray<T>(value?: ArrayLike<T>): value is Array<T> {\n  return Array.isArray(value) && value.length > 0;\n}\n","import { GraphQLError } from 'graphql';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport function isApolloError(err: Error): err is ApolloError {\n  return err.hasOwnProperty('graphQLErrors');\n}\n\n// Sets the error message on this error according to the\n// the GraphQL and network errors that are present.\n// If the error message has already been set through the\n// constructor or otherwise, this function is a nop.\nconst generateErrorMessage = (err: ApolloError) => {\n  let message = '';\n  // If we have GraphQL errors present, add that to the error message.\n  if (isNonEmptyArray(err.graphQLErrors)) {\n    err.graphQLErrors.forEach((graphQLError: GraphQLError) => {\n      const errorMessage = graphQLError\n        ? graphQLError.message\n        : 'Error message not found.';\n      message += `GraphQL error: ${errorMessage}\\n`;\n    });\n  }\n\n  if (err.networkError) {\n    message += 'Network error: ' + err.networkError.message + '\\n';\n  }\n\n  // strip newline from the end of the message\n  message = message.replace(/\\n$/, '');\n  return message;\n};\n\nexport class ApolloError extends Error {\n  public message: string;\n  public graphQLErrors: ReadonlyArray<GraphQLError>;\n  public networkError: Error | null;\n\n  // An object that can be used to provide some additional information\n  // about an error, e.g. specifying the type of error this is. Used\n  // internally within Apollo Client.\n  public extraInfo: any;\n\n  // Constructs an instance of ApolloError given a GraphQLError\n  // or a network error. Note that one of these has to be a valid\n  // value or the constructed error will be meaningless.\n  constructor({\n    graphQLErrors,\n    networkError,\n    errorMessage,\n    extraInfo,\n  }: {\n    graphQLErrors?: ReadonlyArray<GraphQLError>;\n    networkError?: Error | null;\n    errorMessage?: string;\n    extraInfo?: any;\n  }) {\n    super(errorMessage);\n    this.graphQLErrors = graphQLErrors || [];\n    this.networkError = networkError || null;\n\n    if (!errorMessage) {\n      this.message = generateErrorMessage(this);\n    } else {\n      this.message = errorMessage;\n    }\n\n    this.extraInfo = extraInfo;\n\n    // We're not using `Object.setPrototypeOf` here as it isn't fully\n    // supported on Android (see issue #3236).\n    (this as any).__proto__ = ApolloError.prototype;\n  }\n}\n","import { FetchResult } from 'apollo-link';\nimport { DocumentNode, GraphQLError } from 'graphql';\n\nimport { QueryStoreValue } from '../data/queries';\nimport { NetworkStatus } from './networkStatus';\nimport { Resolver } from './LocalState';\n\nexport type QueryListener = (\n  queryStoreValue: QueryStoreValue,\n  newData?: any,\n  forceResolvers?: boolean,\n) => void;\n\nexport type OperationVariables = { [key: string]: any };\n\nexport type PureQueryOptions = {\n  query: DocumentNode;\n  variables?: { [key: string]: any };\n  context?: any;\n};\n\nexport type ApolloQueryResult<T> = {\n  data: T;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  stale: boolean;\n};\n\nexport enum FetchType {\n  normal = 1,\n  refetch = 2,\n  poll = 3,\n}\n\n// This is part of the public API, people write these functions in `updateQueries`.\nexport type MutationQueryReducer<T> = (\n  previousResult: Record<string, any>,\n  options: {\n    mutationResult: FetchResult<T>;\n    queryName: string | undefined;\n    queryVariables: Record<string, any>;\n  },\n) => Record<string, any>;\n\nexport type MutationQueryReducersMap<T = { [key: string]: any }> = {\n  [queryName: string]: MutationQueryReducer<T>;\n};\n\nexport interface Resolvers {\n  [key: string]: {\n    [ field: string ]: Resolver;\n  };\n}\n","import {\n  isEqual,\n  tryFunctionOrLogError,\n  cloneDeep,\n  getOperationDefinition,\n} from 'apollo-utilities';\nimport { GraphQLError } from 'graphql';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport { Observable, Observer, Subscription } from '../util/Observable';\nimport { ApolloError } from '../errors/ApolloError';\nimport { QueryManager } from './QueryManager';\nimport { ApolloQueryResult, FetchType, OperationVariables } from './types';\nimport {\n  WatchQueryOptions,\n  FetchMoreQueryOptions,\n  SubscribeToMoreOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\n\nimport { QueryStoreValue } from '../data/queries';\n\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isNonEmptyArray } from '../util/arrays';\n\n// XXX remove in the next breaking semver change (3.0)\n// Deprecated, use ApolloCurrentQueryResult\nexport type ApolloCurrentResult<T> = {\n  data: T | {};\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n};\n\nexport type ApolloCurrentQueryResult<T> = {\n  data: T | undefined;\n  errors?: ReadonlyArray<GraphQLError>;\n  loading: boolean;\n  networkStatus: NetworkStatus;\n  error?: ApolloError;\n  partial?: boolean;\n  stale?: boolean;\n};\n\nexport interface FetchMoreOptions<\n  TData = any,\n  TVariables = OperationVariables\n> {\n  updateQuery: (\n    previousQueryResult: TData,\n    options: {\n      fetchMoreResult?: TData;\n      variables?: TVariables;\n    },\n  ) => TData;\n}\n\nexport interface UpdateQueryOptions<TVariables> {\n  variables?: TVariables;\n}\n\nexport const hasError = (\n  storeValue: QueryStoreValue,\n  policy: ErrorPolicy = 'none',\n) => storeValue && (\n  storeValue.networkError ||\n  (policy === 'none' && isNonEmptyArray(storeValue.graphQLErrors))\n);\n\nexport class ObservableQuery<\n  TData = any,\n  TVariables = OperationVariables\n> extends Observable<ApolloQueryResult<TData>> {\n  public options: WatchQueryOptions<TVariables>;\n  public readonly queryId: string;\n  public readonly queryName?: string;\n  /**\n   *\n   * The current value of the variables for this query. Can change.\n   */\n  public variables: TVariables;\n\n  private shouldSubscribe: boolean;\n  private isTornDown: boolean;\n  private queryManager: QueryManager<any>;\n  private observers = new Set<Observer<ApolloQueryResult<TData>>>();\n  private subscriptions = new Set<Subscription>();\n\n  private lastResult: ApolloQueryResult<TData>;\n  private lastResultSnapshot: ApolloQueryResult<TData>;\n  private lastError: ApolloError;\n\n  constructor({\n    queryManager,\n    options,\n    shouldSubscribe = true,\n  }: {\n    queryManager: QueryManager<any>;\n    options: WatchQueryOptions<TVariables>;\n    shouldSubscribe?: boolean;\n  }) {\n    super((observer: Observer<ApolloQueryResult<TData>>) =>\n      this.onSubscribe(observer),\n    );\n\n    // active state\n    this.isTornDown = false;\n\n    // query information\n    this.options = options;\n    this.variables = options.variables || ({} as TVariables);\n    this.queryId = queryManager.generateQueryId();\n    this.shouldSubscribe = shouldSubscribe;\n\n    const opDef = getOperationDefinition(options.query);\n    this.queryName = opDef && opDef.name && opDef.name.value;\n\n    // related classes\n    this.queryManager = queryManager;\n  }\n\n  public result(): Promise<ApolloQueryResult<TData>> {\n    return new Promise((resolve, reject) => {\n      const observer: Observer<ApolloQueryResult<TData>> = {\n        next: (result: ApolloQueryResult<TData>) => {\n          resolve(result);\n\n          // Stop the query within the QueryManager if we can before\n          // this function returns.\n          //\n          // We do this in order to prevent observers piling up within\n          // the QueryManager. Notice that we only fully unsubscribe\n          // from the subscription in a setTimeout(..., 0)  call. This call can\n          // actually be handled by the browser at a much later time. If queries\n          // are fired in the meantime, observers that should have been removed\n          // from the QueryManager will continue to fire, causing an unnecessary\n          // performance hit.\n          this.observers.delete(observer);\n          if (!this.observers.size) {\n            this.queryManager.removeQuery(this.queryId);\n          }\n\n          setTimeout(() => {\n            subscription.unsubscribe();\n          }, 0);\n        },\n        error: reject,\n      };\n      const subscription = this.subscribe(observer);\n    });\n  }\n\n  // XXX remove in the next breaking semver change (3.0)\n  // Deprecated, use getCurrentResult()\n  public currentResult(): ApolloCurrentResult<TData> {\n    const result = this.getCurrentResult() as ApolloCurrentResult<TData>;\n    if (result.data === undefined) {\n      result.data = {};\n    }\n    return result;\n  }\n\n  /**\n   * Return the result of the query from the local cache as well as some fetching status\n   * `loading` and `networkStatus` allow to know if a request is in flight\n   * `partial` lets you know if the result from the local cache is complete or partial\n   * @return {data: Object, error: ApolloError, loading: boolean, networkStatus: number, partial: boolean}\n   */\n  public getCurrentResult(): ApolloCurrentQueryResult<TData> {\n    if (this.isTornDown) {\n      const { lastResult } = this;\n      return {\n        data: !this.lastError && lastResult && lastResult.data || void 0,\n        error: this.lastError,\n        loading: false,\n        networkStatus: NetworkStatus.error,\n      };\n    }\n\n    const { data, partial } = this.queryManager.getCurrentQueryResult(this);\n    const queryStoreValue = this.queryManager.queryStore.get(this.queryId);\n    let result: ApolloQueryResult<TData>;\n\n    const { fetchPolicy } = this.options;\n\n    const isNetworkFetchPolicy =\n      fetchPolicy === 'network-only' ||\n      fetchPolicy === 'no-cache';\n\n    if (queryStoreValue) {\n      const { networkStatus } = queryStoreValue;\n\n      if (hasError(queryStoreValue, this.options.errorPolicy)) {\n        return {\n          data: void 0,\n          loading: false,\n          networkStatus,\n          error: new ApolloError({\n            graphQLErrors: queryStoreValue.graphQLErrors,\n            networkError: queryStoreValue.networkError,\n          }),\n        };\n      }\n\n      // Variables might have been added dynamically at query time, when\n      // using `@client @export(as: \"varname\")` for example. When this happens,\n      // the variables have been updated in the query store, but not updated on\n      // the original `ObservableQuery`. We'll update the observable query\n      // variables here to match, so retrieving from the cache doesn't fail.\n      if (queryStoreValue.variables) {\n        this.options.variables = {\n          ...this.options.variables,\n          ...(queryStoreValue.variables as TVariables),\n        };\n        this.variables = this.options.variables;\n      }\n\n      result = {\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n      } as ApolloQueryResult<TData>;\n\n      if (queryStoreValue.graphQLErrors && this.options.errorPolicy === 'all') {\n        result.errors = queryStoreValue.graphQLErrors;\n      }\n\n    } else {\n      // We need to be careful about the loading state we show to the user, to try\n      // and be vaguely in line with what the user would have seen from .subscribe()\n      // but to still provide useful information synchronously when the query\n      // will not end up hitting the server.\n      // See more: https://github.com/apollostack/apollo-client/issues/707\n      // Basically: is there a query in flight right now (modolo the next tick)?\n      const loading = isNetworkFetchPolicy ||\n        (partial && fetchPolicy !== 'cache-only');\n\n      result = {\n        data,\n        loading,\n        networkStatus: loading ? NetworkStatus.loading : NetworkStatus.ready,\n      } as ApolloQueryResult<TData>;\n    }\n\n    if (!partial) {\n      this.updateLastResult({ ...result, stale: false });\n    }\n\n    return { ...result, partial };\n  }\n\n  // Compares newResult to the snapshot we took of this.lastResult when it was\n  // first received.\n  public isDifferentFromLastResult(newResult: ApolloQueryResult<TData>) {\n    const { lastResultSnapshot: snapshot } = this;\n    return !(\n      snapshot &&\n      newResult &&\n      snapshot.networkStatus === newResult.networkStatus &&\n      snapshot.stale === newResult.stale &&\n      isEqual(snapshot.data, newResult.data)\n    );\n  }\n\n  // Returns the last result that observer.next was called with. This is not the same as\n  // getCurrentResult! If you're not sure which you need, then you probably need getCurrentResult.\n  public getLastResult(): ApolloQueryResult<TData> {\n    return this.lastResult;\n  }\n\n  public getLastError(): ApolloError {\n    return this.lastError;\n  }\n\n  public resetLastResults(): void {\n    delete this.lastResult;\n    delete this.lastResultSnapshot;\n    delete this.lastError;\n    this.isTornDown = false;\n  }\n\n  public resetQueryStoreErrors() {\n    const queryStore = this.queryManager.queryStore.get(this.queryId);\n    if (queryStore) {\n      queryStore.networkError = null;\n      queryStore.graphQLErrors = [];\n    }\n  }\n\n  /**\n   * Update the variables of this observable query, and fetch the new results.\n   * This method should be preferred over `setVariables` in most use cases.\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   */\n  public refetch(variables?: TVariables): Promise<ApolloQueryResult<TData>> {\n    let { fetchPolicy } = this.options;\n    // early return if trying to read from cache during refetch\n    if (fetchPolicy === 'cache-only') {\n      return Promise.reject(new InvariantError(\n        'cache-only fetchPolicy option should not be used together with query refetch.',\n      ));\n    }\n\n    // Unless the provided fetchPolicy always consults the network\n    // (no-cache, network-only, or cache-and-network), override it with\n    // network-only to force the refetch for this fetchQuery call.\n    if (fetchPolicy !== 'no-cache' &&\n        fetchPolicy !== 'cache-and-network') {\n      fetchPolicy = 'network-only';\n    }\n\n    if (!isEqual(this.variables, variables)) {\n      // update observable variables\n      this.variables = {\n        ...this.variables,\n        ...variables,\n      };\n    }\n\n    if (!isEqual(this.options.variables, this.variables)) {\n      // Update the existing options with new variables\n      this.options.variables = {\n        ...this.options.variables,\n        ...this.variables,\n      };\n    }\n\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      { ...this.options, fetchPolicy },\n      FetchType.refetch,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public fetchMore<K extends keyof TVariables>(\n    fetchMoreOptions: FetchMoreQueryOptions<TVariables, K> &\n      FetchMoreOptions<TData, TVariables>,\n  ): Promise<ApolloQueryResult<TData>> {\n    // early return if no update Query\n    invariant(\n      fetchMoreOptions.updateQuery,\n      'updateQuery option is required. This function defines how to update the query data with the new results.',\n    );\n\n    const combinedOptions = {\n      ...(fetchMoreOptions.query ? fetchMoreOptions : {\n        ...this.options,\n        ...fetchMoreOptions,\n        variables: {\n          ...this.variables,\n          ...fetchMoreOptions.variables,\n        },\n      }),\n      fetchPolicy: 'network-only',\n    } as WatchQueryOptions;\n\n    const qid = this.queryManager.generateQueryId();\n\n    return this.queryManager\n      .fetchQuery(\n        qid,\n        combinedOptions,\n        FetchType.normal,\n        this.queryId,\n      )\n      .then(\n        fetchMoreResult => {\n          this.updateQuery((previousResult: any) =>\n            fetchMoreOptions.updateQuery(previousResult, {\n              fetchMoreResult: fetchMoreResult.data as TData,\n              variables: combinedOptions.variables as TVariables,\n            }),\n          );\n          this.queryManager.stopQuery(qid);\n          return fetchMoreResult as ApolloQueryResult<TData>;\n        },\n        error => {\n          this.queryManager.stopQuery(qid);\n          throw error;\n        },\n      );\n  }\n\n  // XXX the subscription variables are separate from the query variables.\n  // if you want to update subscription variables, right now you have to do that separately,\n  // and you can only do it by stopping the subscription and then subscribing again with new variables.\n  public subscribeToMore<\n    TSubscriptionData = TData,\n    TSubscriptionVariables = TVariables\n  >(\n    options: SubscribeToMoreOptions<\n      TData,\n      TSubscriptionVariables,\n      TSubscriptionData\n    >,\n  ) {\n    const subscription = this.queryManager\n      .startGraphQLSubscription({\n        query: options.document,\n        variables: options.variables,\n      })\n      .subscribe({\n        next: (subscriptionData: { data: TSubscriptionData }) => {\n          const { updateQuery } = options;\n          if (updateQuery) {\n            this.updateQuery<TSubscriptionVariables>(\n              (previous, { variables }) =>\n                updateQuery(previous, {\n                  subscriptionData,\n                  variables,\n                }),\n            );\n          }\n        },\n        error: (err: any) => {\n          if (options.onError) {\n            options.onError(err);\n            return;\n          }\n          invariant.error('Unhandled GraphQL subscription error', err);\n        },\n      });\n\n    this.subscriptions.add(subscription);\n\n    return () => {\n      if (this.subscriptions.delete(subscription)) {\n        subscription.unsubscribe();\n      }\n    };\n  }\n\n  // Note: if the query is not active (there are no subscribers), the promise\n  // will return null immediately.\n  public setOptions(\n    opts: WatchQueryOptions,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    const { fetchPolicy: oldFetchPolicy } = this.options;\n    this.options = {\n      ...this.options,\n      ...opts,\n    } as WatchQueryOptions<TVariables>;\n\n    if (opts.pollInterval) {\n      this.startPolling(opts.pollInterval);\n    } else if (opts.pollInterval === 0) {\n      this.stopPolling();\n    }\n\n    const { fetchPolicy } = opts;\n\n    return this.setVariables(\n      this.options.variables as TVariables,\n      // Try to fetch the query if fetchPolicy changed from either cache-only\n      // or standby to something else, or changed to network-only.\n      oldFetchPolicy !== fetchPolicy && (\n        oldFetchPolicy === 'cache-only' ||\n        oldFetchPolicy === 'standby' ||\n        fetchPolicy === 'network-only'\n      ),\n      opts.fetchResults,\n    );\n  }\n\n  /**\n   * This is for *internal* use only. Most users should instead use `refetch`\n   * in order to be properly notified of results even when they come from cache.\n   *\n   * Update the variables of this observable query, and fetch the new results\n   * if they've changed. If you want to force new results, use `refetch`.\n   *\n   * Note: the `next` callback will *not* fire if the variables have not changed\n   * or if the result is coming from cache.\n   *\n   * Note: the promise will return the old results immediately if the variables\n   * have not changed.\n   *\n   * Note: the promise will return null immediately if the query is not active\n   * (there are no subscribers).\n   *\n   * @private\n   *\n   * @param variables: The new set of variables. If there are missing variables,\n   * the previous values of those variables will be used.\n   *\n   * @param tryFetch: Try and fetch new results even if the variables haven't\n   * changed (we may still just hit the store, but if there's nothing in there\n   * this will refetch)\n   *\n   * @param fetchResults: Option to ignore fetching results when updating variables\n   */\n  public setVariables(\n    variables: TVariables,\n    tryFetch: boolean = false,\n    fetchResults = true,\n  ): Promise<ApolloQueryResult<TData> | void> {\n    // since setVariables restarts the subscription, we reset the tornDown status\n    this.isTornDown = false;\n\n    variables = variables || this.variables;\n\n    if (!tryFetch && isEqual(variables, this.variables)) {\n      // If we have no observers, then we don't actually want to make a network\n      // request. As soon as someone observes the query, the request will kick\n      // off. For now, we just store any changes. (See #1077)\n      return this.observers.size && fetchResults\n        ? this.result()\n        : Promise.resolve();\n    }\n\n    this.variables = this.options.variables = variables;\n\n    // See comment above\n    if (!this.observers.size) {\n      return Promise.resolve();\n    }\n\n    // Use the same options as before, but with new variables\n    return this.queryManager.fetchQuery(\n      this.queryId,\n      this.options,\n    ) as Promise<ApolloQueryResult<TData>>;\n  }\n\n  public updateQuery<TVars = TVariables>(\n    mapFn: (\n      previousQueryResult: TData,\n      options: UpdateQueryOptions<TVars>,\n    ) => TData,\n  ): void {\n    const { queryManager } = this;\n    const {\n      previousResult,\n      variables,\n      document,\n    } = queryManager.getQueryWithPreviousResult<TData, TVars>(\n      this.queryId,\n    );\n\n    const newResult = tryFunctionOrLogError(() =>\n      mapFn(previousResult, { variables }),\n    );\n\n    if (newResult) {\n      queryManager.dataStore.markUpdateQueryResult(\n        document,\n        variables,\n        newResult,\n      );\n      queryManager.broadcastQueries();\n    }\n  }\n\n  public stopPolling() {\n    this.queryManager.stopPollingQuery(this.queryId);\n    this.options.pollInterval = undefined;\n  }\n\n  public startPolling(pollInterval: number) {\n    assertNotCacheFirstOrOnly(this);\n    this.options.pollInterval = pollInterval;\n    this.queryManager.startPollingQuery(this.options, this.queryId);\n  }\n\n  private updateLastResult(newResult: ApolloQueryResult<TData>) {\n    const previousResult = this.lastResult;\n    this.lastResult = newResult;\n    this.lastResultSnapshot = this.queryManager.assumeImmutableResults\n      ? newResult\n      : cloneDeep(newResult);\n    return previousResult;\n  }\n\n  private onSubscribe(observer: Observer<ApolloQueryResult<TData>>) {\n    // Zen Observable has its own error function, so in order to log correctly\n    // we need to provide a custom error callback.\n    try {\n      var subObserver = (observer as any)._subscription._observer;\n      if (subObserver && !subObserver.error) {\n        subObserver.error = defaultSubscriptionObserverErrorCallback;\n      }\n    } catch {}\n\n    const first = !this.observers.size;\n    this.observers.add(observer);\n\n    // Deliver initial result\n    if (observer.next && this.lastResult) observer.next(this.lastResult);\n    if (observer.error && this.lastError) observer.error(this.lastError);\n\n    // setup the query if it hasn't been done before\n    if (first) {\n      this.setUpQuery();\n    }\n\n    return () => {\n      if (this.observers.delete(observer) && !this.observers.size) {\n        this.tearDownQuery();\n      }\n    };\n  }\n\n  private setUpQuery() {\n    const { queryManager, queryId } = this;\n\n    if (this.shouldSubscribe) {\n      queryManager.addObservableQuery<TData>(queryId, this);\n    }\n\n    if (this.options.pollInterval) {\n      assertNotCacheFirstOrOnly(this);\n      queryManager.startPollingQuery(this.options, queryId);\n    }\n\n    const onError = (error: ApolloError) => {\n      // Since we don't get the current result on errors, only the error, we\n      // must mirror the updates that occur in QueryStore.markQueryError here\n      this.updateLastResult({\n        ...this.lastResult,\n        errors: error.graphQLErrors,\n        networkStatus: NetworkStatus.error,\n        loading: false,\n      });\n      iterateObserversSafely(this.observers, 'error', this.lastError = error);\n    };\n\n    queryManager.observeQuery<TData>(queryId, this.options, {\n      next: (result: ApolloQueryResult<TData>) => {\n        if (this.lastError || this.isDifferentFromLastResult(result)) {\n          const previousResult = this.updateLastResult(result);\n          const { query, variables, fetchPolicy } = this.options;\n\n          // Before calling `next` on each observer, we need to first see if\n          // the query is using `@client @export` directives, and update\n          // any variables that might have changed. If `@export` variables have\n          // changed, and the query is calling against both local and remote\n          // data, a refetch is needed to pull in new data, using the\n          // updated `@export` variables.\n          if (queryManager.transform(query).hasClientExports) {\n            queryManager.getLocalState().addExportedVariables(\n              query,\n              variables,\n            ).then((variables: TVariables) => {\n              const previousVariables = this.variables;\n              this.variables = this.options.variables = variables;\n              if (\n                !result.loading &&\n                previousResult &&\n                fetchPolicy !== 'cache-only' &&\n                queryManager.transform(query).serverQuery &&\n                !isEqual(previousVariables, variables)\n              ) {\n                this.refetch();\n              } else {\n                iterateObserversSafely(this.observers, 'next', result);\n              }\n            });\n          } else {\n            iterateObserversSafely(this.observers, 'next', result);\n          }\n        }\n      },\n      error: onError,\n    }).catch(onError);\n  }\n\n  private tearDownQuery() {\n    const { queryManager } = this;\n\n    this.isTornDown = true;\n    queryManager.stopPollingQuery(this.queryId);\n\n    // stop all active GraphQL subscriptions\n    this.subscriptions.forEach(sub => sub.unsubscribe());\n    this.subscriptions.clear();\n\n    queryManager.removeObservableQuery(this.queryId);\n    queryManager.stopQuery(this.queryId);\n\n    this.observers.clear();\n  }\n}\n\nfunction defaultSubscriptionObserverErrorCallback(error: ApolloError) {\n  invariant.error('Unhandled error', error.message, error.stack);\n}\n\nfunction iterateObserversSafely<E, A>(\n  observers: Set<Observer<E>>,\n  method: keyof Observer<E>,\n  argument?: A,\n) {\n  // In case observers is modified during iteration, we need to commit to the\n  // original elements, which also provides an opportunity to filter them down\n  // to just the observers with the given method.\n  const observersWithMethod: Observer<E>[] = [];\n  observers.forEach(obs => obs[method] && observersWithMethod.push(obs));\n  observersWithMethod.forEach(obs => (obs as any)[method](argument));\n}\n\nfunction assertNotCacheFirstOrOnly<TData, TVariables>(\n  obsQuery: ObservableQuery<TData, TVariables>,\n) {\n  const { fetchPolicy } = obsQuery.options;\n  invariant(\n    fetchPolicy !== 'cache-first' && fetchPolicy !== 'cache-only',\n    'Queries that specify the cache-first and cache-only fetchPolicies cannot also be polling queries.',\n  );\n}\n","import { DocumentNode } from 'graphql';\n\nexport class MutationStore {\n  private store: { [mutationId: string]: MutationStoreValue } = {};\n\n  public getStore(): { [mutationId: string]: MutationStoreValue } {\n    return this.store;\n  }\n\n  public get(mutationId: string): MutationStoreValue {\n    return this.store[mutationId];\n  }\n\n  public initMutation(\n    mutationId: string,\n    mutation: DocumentNode,\n    variables: Object | undefined,\n  ) {\n    this.store[mutationId] = {\n      mutation,\n      variables: variables || {},\n      loading: true,\n      error: null,\n    };\n  }\n\n  public markMutationError(mutationId: string, error: Error) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = error;\n    }\n  }\n\n  public markMutationResult(mutationId: string) {\n    const mutation = this.store[mutationId];\n    if (mutation) {\n      mutation.loading = false;\n      mutation.error = null;\n    }\n  }\n\n  public reset() {\n    this.store = {};\n  }\n}\n\nexport interface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Object;\n  loading: boolean;\n  error: Error | null;\n}\n","import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';\nimport { isEqual } from 'apollo-utilities';\nimport { invariant } from 'ts-invariant';\nimport { NetworkStatus } from '../core/networkStatus';\nimport { isNonEmptyArray } from '../util/arrays';\n\nexport type QueryStoreValue = {\n  document: DocumentNode;\n  variables: Object;\n  previousVariables?: Object | null;\n  networkStatus: NetworkStatus;\n  networkError?: Error | null;\n  graphQLErrors?: ReadonlyArray<GraphQLError>;\n  metadata: any;\n};\n\nexport class QueryStore {\n  private store: { [queryId: string]: QueryStoreValue } = {};\n\n  public getStore(): { [queryId: string]: QueryStoreValue } {\n    return this.store;\n  }\n\n  public get(queryId: string): QueryStoreValue {\n    return this.store[queryId];\n  }\n\n  public initQuery(query: {\n    queryId: string;\n    document: DocumentNode;\n    storePreviousVariables: boolean;\n    variables: Object;\n    isPoll: boolean;\n    isRefetch: boolean;\n    metadata: any;\n    fetchMoreForQueryId: string | undefined;\n  }) {\n    const previousQuery = this.store[query.queryId];\n\n    // XXX we're throwing an error here to catch bugs where a query gets overwritten by a new one.\n    // we should implement a separate action for refetching so that QUERY_INIT may never overwrite\n    // an existing query (see also: https://github.com/apollostack/apollo-client/issues/732)\n    invariant(\n      !previousQuery ||\n      previousQuery.document === query.document ||\n      isEqual(previousQuery.document, query.document),\n      'Internal Error: may not update existing query string in store',\n    );\n\n    let isSetVariables = false;\n\n    let previousVariables: Object | null = null;\n    if (\n      query.storePreviousVariables &&\n      previousQuery &&\n      previousQuery.networkStatus !== NetworkStatus.loading\n      // if the previous query was still loading, we don't want to remember it at all.\n    ) {\n      if (!isEqual(previousQuery.variables, query.variables)) {\n        isSetVariables = true;\n        previousVariables = previousQuery.variables;\n      }\n    }\n\n    // TODO break this out into a separate function\n    let networkStatus;\n    if (isSetVariables) {\n      networkStatus = NetworkStatus.setVariables;\n    } else if (query.isPoll) {\n      networkStatus = NetworkStatus.poll;\n    } else if (query.isRefetch) {\n      networkStatus = NetworkStatus.refetch;\n      // TODO: can we determine setVariables here if it's a refetch and the variables have changed?\n    } else {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    let graphQLErrors: ReadonlyArray<GraphQLError> = [];\n    if (previousQuery && previousQuery.graphQLErrors) {\n      graphQLErrors = previousQuery.graphQLErrors;\n    }\n\n    // XXX right now if QUERY_INIT is fired twice, like in a refetch situation, we just overwrite\n    // the store. We probably want a refetch action instead, because I suspect that if you refetch\n    // before the initial fetch is done, you'll get an error.\n    this.store[query.queryId] = {\n      document: query.document,\n      variables: query.variables,\n      previousVariables,\n      networkError: null,\n      graphQLErrors: graphQLErrors,\n      networkStatus,\n      metadata: query.metadata,\n    };\n\n    // If the action had a `moreForQueryId` property then we need to set the\n    // network status on that query as well to `fetchMore`.\n    //\n    // We have a complement to this if statement in the query result and query\n    // error action branch, but importantly *not* in the client result branch.\n    // This is because the implementation of `fetchMore` *always* sets\n    // `fetchPolicy` to `network-only` so we would never have a client result.\n    if (\n      typeof query.fetchMoreForQueryId === 'string' &&\n      this.store[query.fetchMoreForQueryId]\n    ) {\n      this.store[query.fetchMoreForQueryId].networkStatus =\n        NetworkStatus.fetchMore;\n    }\n  }\n\n  public markQueryResult(\n    queryId: string,\n    result: ExecutionResult,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = null;\n    this.store[queryId].graphQLErrors = isNonEmptyArray(result.errors) ? result.errors : [];\n    this.store[queryId].previousVariables = null;\n    this.store[queryId].networkStatus = NetworkStatus.ready;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (\n      typeof fetchMoreForQueryId === 'string' &&\n      this.store[fetchMoreForQueryId]\n    ) {\n      this.store[fetchMoreForQueryId].networkStatus = NetworkStatus.ready;\n    }\n  }\n\n  public markQueryError(\n    queryId: string,\n    error: Error,\n    fetchMoreForQueryId: string | undefined,\n  ) {\n    if (!this.store || !this.store[queryId]) return;\n\n    this.store[queryId].networkError = error;\n    this.store[queryId].networkStatus = NetworkStatus.error;\n\n    // If we have a `fetchMoreForQueryId` then we need to update the network\n    // status for that query. See the branch for query initialization for more\n    // explanation about this process.\n    if (typeof fetchMoreForQueryId === 'string') {\n      this.markQueryResultClient(fetchMoreForQueryId, true);\n    }\n  }\n\n  public markQueryResultClient(queryId: string, complete: boolean) {\n    const storeValue = this.store && this.store[queryId];\n    if (storeValue) {\n      storeValue.networkError = null;\n      storeValue.previousVariables = null;\n      if (complete) {\n        storeValue.networkStatus = NetworkStatus.ready;\n      }\n    }\n  }\n\n  public stopQuery(queryId: string) {\n    delete this.store[queryId];\n  }\n\n  public reset(observableQueryIds: string[]) {\n    Object.keys(this.store).forEach(queryId => {\n      if (observableQueryIds.indexOf(queryId) < 0) {\n        this.stopQuery(queryId);\n      } else {\n        // XXX set loading to true so listeners don't trigger unless they want results with partial data\n        this.store[queryId].networkStatus = NetworkStatus.loading;\n      }\n    });\n  }\n}\n","export function capitalizeFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n} from 'graphql';\nimport { visit, BREAK } from 'graphql/language/visitor';\n\nimport { ApolloCache } from 'apollo-cache';\nimport {\n  getMainDefinition,\n  buildQueryFromSelectionSet,\n  hasDirectives,\n  removeClientSetsFromDocument,\n  mergeDeep,\n  mergeDeepArray,\n  FragmentMap,\n  argumentsObjectFromField,\n  resultKeyNameFromField,\n  getFragmentDefinitions,\n  createFragmentMap,\n  shouldInclude,\n  isField,\n  isInlineFragment,\n} from 'apollo-utilities';\nimport { FetchResult } from 'apollo-link';\n\nimport { invariant } from 'ts-invariant';\n\nimport ApolloClient from '../ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { capitalizeFirstLetter } from '../util/capitalizeFirstLetter';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n      invariant.warn(\n        'Found @client directives in a query but no ApolloClient resolvers ' +\n        'were specified. This means ApolloClient local resolver handling ' +\n        'has been disabled, and @client directives will be passed through ' +\n        'to your link chain.',\n      );\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return this.resolvers ? removeClientSetsFromDocument(document) : document;\n  }\n\n  public prepareContext(context = {}) {\n    const { cache } = this;\n\n    const newContext = {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey: (obj: { __typename: string; id: string | number }) => {\n        if ((cache as any).config) {\n          return (cache as any).config.dataIdFromObject(obj);\n        } else {\n          invariant(false,\n            'To use context.getCacheKey, you need to use a cache that has ' +\n              'a configurable dataIdFromObject, like apollo-cache-inmemory.',\n          );\n        }\n      },\n    };\n\n    return newContext;\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? capitalizeFirstLetter(definitionOperation)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(resolve(\n            rootValue,\n            argumentsObjectFromField(field, variables),\n            execContext.context,\n            { field, fragmentMap: execContext.fragmentMap },\n          ));\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n","import { Observable, Observer, Subscription } from './Observable';\n\n// Returns a normal Observable that can have any number of subscribers,\n// while ensuring the original Observable gets subscribed to at most once.\nexport function multiplex<T>(inner: Observable<T>): Observable<T> {\n  const observers = new Set<Observer<T>>();\n  let sub: Subscription | null = null;\n  return new Observable<T>(observer => {\n    observers.add(observer);\n    sub = sub || inner.subscribe({\n      next(value) {\n        observers.forEach(obs => obs.next && obs.next(value));\n      },\n      error(error) {\n        observers.forEach(obs => obs.error && obs.error(error));\n      },\n      complete() {\n        observers.forEach(obs => obs.complete && obs.complete());\n      },\n    });\n    return () => {\n      if (observers.delete(observer) && !observers.size && sub) {\n        sub.unsubscribe();\n        sub = null;\n      }\n    };\n  });\n}\n\n// Like Observable.prototype.map, except that the mapping function can\n// optionally return a Promise (or be async).\nexport function asyncMap<V, R>(\n  observable: Observable<V>,\n  mapFn: (value: V) => R | Promise<R>,\n): Observable<R> {\n  return new Observable<R>(observer => {\n    const { next, error, complete } = observer;\n    let activeNextCount = 0;\n    let completed = false;\n\n    const handler: Observer<V> = {\n      next(value) {\n        ++activeNextCount;\n        new Promise(resolve => {\n          resolve(mapFn(value));\n        }).then(\n          result => {\n            --activeNextCount;\n            next && next.call(observer, result);\n            completed && handler.complete!();\n          },\n          e => {\n            --activeNextCount;\n            error && error.call(observer, e);\n          },\n        );\n      },\n      error(e) {\n        error && error.call(observer, e);\n      },\n      complete() {\n        completed = true;\n        if (!activeNextCount) {\n          complete && complete.call(observer);\n        }\n      },\n    };\n\n    const sub = observable.subscribe(handler);\n    return () => sub.unsubscribe();\n  });\n}\n","import { execute, ApolloLink, FetchResult } from 'apollo-link';\nimport { DocumentNode } from 'graphql';\nimport { Cache } from 'apollo-cache';\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasDirectives,\n  graphQLResultHasError,\n  hasClientExports,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n} from 'apollo-utilities';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { isApolloError, ApolloError } from '../errors/ApolloError';\nimport { Observer, Subscription, Observable } from '../util/Observable';\nimport { QueryWithUpdater, DataStore } from '../data/store';\nimport { MutationStore } from '../data/mutations';\nimport { QueryStore, QueryStoreValue } from '../data/queries';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  QueryListener,\n  ApolloQueryResult,\n  FetchType,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\nimport { asyncMap, multiplex } from '../util/observables';\nimport { isNonEmptyArray } from '../util/arrays';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport interface QueryInfo {\n  listeners: Set<QueryListener>;\n  invalidated: boolean;\n  newData: Cache.DiffResult<any> | null;\n  document: DocumentNode | null;\n  lastRequestId: number;\n  // A map going from queryId to an observer for a query issued by watchQuery. We use\n  // these to keep track of queries that are inflight and error on the observers associated\n  // with them in case of some destabalizing action (e.g. reset of the Apollo store).\n  observableQuery: ObservableQuery<any> | null;\n  subscriptions: Set<Subscription>;\n  cancel?: () => void;\n}\n\nexport class QueryManager<TStore> {\n  public link: ApolloLink;\n  public mutationStore: MutationStore = new MutationStore();\n  public queryStore: QueryStore = new QueryStore();\n  public dataStore: DataStore<TStore>;\n  public readonly assumeImmutableResults: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast: () => void;\n\n  private ssrMode: boolean;\n\n  // let's not start at zero to avoid pain with bad checks\n  private idCounter = 1;\n\n  // XXX merge with ObservableQuery but that needs to be expanded to support mutations and\n  // subscriptions as well\n  private queries: Map<string, QueryInfo> = new Map();\n\n  // A map of Promise reject functions for fetchQuery promises that have not\n  // yet been resolved, used to keep track of in-flight queries so that we can\n  // reject them in case a destabilizing event occurs (e.g. Apollo store reset).\n  // The key is in the format of `query:${queryId}` or `fetchRequest:${queryId}`,\n  // depending on where the promise's rejection function was created from.\n  private fetchQueryRejectFns = new Map<string, Function>();\n\n  constructor({\n    link,\n    queryDeduplication = false,\n    store,\n    onBroadcast = () => undefined,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    store: DataStore<TStore>;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.dataStore = store;\n    this.onBroadcast = onBroadcast;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache: store.getCache() });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(\n        new InvariantError('QueryManager stopped while query was in flight'),\n      );\n    });\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries: updateQueriesByName,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateQueryId();\n    mutation = this.transform(mutation).document;\n\n    this.setQuery(mutationId, () => ({ document: mutation }));\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    // Create a map of update queries by id to the query instead of by name.\n    const generateUpdateQueriesInfo: () => {\n      [queryId: string]: QueryWithUpdater;\n    } = () => {\n      const ret: { [queryId: string]: QueryWithUpdater } = {};\n\n      if (updateQueriesByName) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          if (observableQuery) {\n            const { queryName } = observableQuery;\n            if (\n              queryName &&\n              hasOwnProperty.call(updateQueriesByName, queryName)\n            ) {\n              ret[queryId] = {\n                updater: updateQueriesByName[queryName],\n                query: this.queryStore.get(queryId),\n              };\n            }\n          }\n        });\n      }\n\n      return ret;\n    };\n\n    this.mutationStore.initMutation(\n      mutationId,\n      mutation,\n      variables,\n    );\n\n    this.dataStore.markMutationInit({\n      mutationId,\n      document: mutation,\n      variables,\n      updateQueries: generateUpdateQueriesInfo(),\n      update: updateWithProxyFn,\n      optimisticResponse,\n    });\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: FetchResult<T>) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          self.mutationStore.markMutationResult(mutationId);\n\n          if (fetchPolicy !== 'no-cache') {\n            self.dataStore.markMutationResult({\n              mutationId,\n              result,\n              document: mutation,\n              variables,\n              updateQueries: generateUpdateQueriesInfo(),\n              update: updateWithProxyFn,\n            });\n          }\n\n          storeResult = result;\n        },\n\n        error(err: Error) {\n          self.mutationStore.markMutationError(mutationId, err);\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n          self.broadcastQueries();\n          self.setQuery(mutationId, () => ({ document: null }));\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error) {\n            self.mutationStore.markMutationError(mutationId, error);\n          }\n\n          self.dataStore.markMutationComplete({\n            mutationId,\n            optimisticResponse,\n          });\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult!);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (\n                    observableQuery &&\n                    observableQuery.queryName === refetchQuery\n                  ) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            self.setQuery(mutationId, () => ({ document: null }));\n\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          });\n        },\n      });\n    });\n  }\n\n  public async fetchQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    fetchType?: FetchType,\n    // This allows us to track if this is a query spawned by a `fetchMore`\n    // call for another query. We need this data to compute the `fetchMore`\n    // network status for the query this is fetching for.\n    fetchMoreForQueryId?: string,\n  ): Promise<FetchResult<T>> {\n    const {\n      metadata = null,\n      fetchPolicy = 'cache-first', // cache-first is the default fetch policy.\n      context = {},\n    } = options;\n\n    const query = this.transform(options.query).document;\n\n    let variables = this.getVariables(query, options.variables);\n\n    if (this.transform(query).hasClientExports) {\n      variables = await this.localState.addExportedVariables(query, variables, context);\n    }\n\n    options = { ...options, variables };\n\n    let storeResult: any;\n    const isNetworkOnly =\n      fetchPolicy === 'network-only' || fetchPolicy === 'no-cache';\n    let needToFetch = isNetworkOnly;\n\n    // Unless we are completely skipping the cache, we want to diff the query\n    // against the cache before we fetch it from the network interface.\n    if (!isNetworkOnly) {\n      const { complete, result } = this.dataStore.getCache().diff({\n        query,\n        variables,\n        returnPartialData: true,\n        optimistic: false,\n      });\n\n      // If we're in here, only fetch if we have missing fields\n      needToFetch = !complete || fetchPolicy === 'cache-and-network';\n      storeResult = result;\n    }\n\n    let shouldFetch =\n      needToFetch && fetchPolicy !== 'cache-only' && fetchPolicy !== 'standby';\n\n    // we need to check to see if this is an operation that uses the @live directive\n    if (hasDirectives(['live'], query)) shouldFetch = true;\n\n    const requestId = this.idCounter++;\n\n    // set up a watcher to listen to cache updates\n    const cancel = fetchPolicy !== 'no-cache'\n      ? this.updateQueryWatch(queryId, query, options)\n      : undefined;\n\n    // Initialize query in store with unique requestId\n    this.setQuery(queryId, () => ({\n      document: query,\n      lastRequestId: requestId,\n      invalidated: true,\n      cancel,\n    }));\n\n    this.invalidate(fetchMoreForQueryId);\n\n    this.queryStore.initQuery({\n      queryId,\n      document: query,\n      storePreviousVariables: shouldFetch,\n      variables,\n      isPoll: fetchType === FetchType.poll,\n      isRefetch: fetchType === FetchType.refetch,\n      metadata,\n      fetchMoreForQueryId,\n    });\n\n    this.broadcastQueries();\n\n    if (shouldFetch) {\n      const networkResult = this.fetchRequest<T>({\n        requestId,\n        queryId,\n        document: query,\n        options,\n        fetchMoreForQueryId,\n      }).catch(error => {\n        // This is for the benefit of `refetch` promises, which currently don't get their errors\n        // through the store like watchQuery observers do\n        if (isApolloError(error)) {\n          throw error;\n        } else {\n          if (requestId >= this.getQuery(queryId).lastRequestId) {\n            this.queryStore.markQueryError(queryId, error, fetchMoreForQueryId);\n            this.invalidate(queryId);\n            this.invalidate(fetchMoreForQueryId);\n            this.broadcastQueries();\n          }\n          throw new ApolloError({ networkError: error });\n        }\n      });\n\n      // we don't return the promise for cache-and-network since it is already\n      // returned below from the cache\n      if (fetchPolicy !== 'cache-and-network') {\n        return networkResult;\n      }\n\n      // however we need to catch the error so it isn't unhandled in case of\n      // network error\n      networkResult.catch(() => {});\n    }\n\n    // If there is no part of the query we need to fetch from the server (or,\n    // fetchPolicy is cache-only), we just write the store result as the final result.\n    this.queryStore.markQueryResultClient(queryId, !shouldFetch);\n    this.invalidate(queryId);\n    this.invalidate(fetchMoreForQueryId);\n\n    if (this.transform(query).hasForcedResolvers) {\n      return this.localState.runResolvers({\n        document: query,\n        remoteResult: { data: storeResult },\n        context,\n        variables,\n        onlyRunForcedResolvers: true,\n      }).then((result: FetchResult<T>) => {\n        this.markQueryResult(\n          queryId,\n          result,\n          options,\n          fetchMoreForQueryId,\n        );\n        this.broadcastQueries();\n        return result;\n      });\n    }\n\n    this.broadcastQueries();\n\n    // If we have no query to send to the server, we should return the result\n    // found within the store.\n    return { data: storeResult };\n  }\n\n  private markQueryResult<TData>(\n    queryId: string,\n    result: FetchResult<TData>,\n    {\n      fetchPolicy,\n      variables,\n      errorPolicy,\n    }: WatchQueryOptions,\n    fetchMoreForQueryId?: string,\n  ) {\n    if (fetchPolicy === 'no-cache') {\n      this.setQuery(queryId, () => ({\n        newData: { result: result.data, complete: true },\n      }));\n    } else {\n      this.dataStore.markQueryResult(\n        result,\n        this.getQuery(queryId).document!,\n        variables,\n        fetchMoreForQueryId,\n        errorPolicy === 'ignore' || errorPolicy === 'all',\n      );\n    }\n  }\n\n  // Returns a query listener that will update the given observer based on the\n  // results (or lack thereof) for a particular query.\n  public queryListenerForObserver<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ): QueryListener {\n    function invoke(method: 'next' | 'error', argument: any) {\n      if (observer[method]) {\n        try {\n          observer[method]!(argument);\n        } catch (e) {\n          invariant.error(e);\n        }\n      } else if (method === 'error') {\n        invariant.error(argument);\n      }\n    }\n\n    return (\n      queryStoreValue: QueryStoreValue,\n      newData?: Cache.DiffResult<T>,\n    ) => {\n      // we're going to take a look at the data, so the query is no longer invalidated\n      this.invalidate(queryId, false);\n\n      // The query store value can be undefined in the event of a store\n      // reset.\n      if (!queryStoreValue) return;\n\n      const { observableQuery, document } = this.getQuery(queryId);\n\n      const fetchPolicy = observableQuery\n        ? observableQuery.options.fetchPolicy\n        : options.fetchPolicy;\n\n      // don't watch the store for queries on standby\n      if (fetchPolicy === 'standby') return;\n\n      const loading = isNetworkRequestInFlight(queryStoreValue.networkStatus);\n      const lastResult = observableQuery && observableQuery.getLastResult();\n\n      const networkStatusChanged = !!(\n        lastResult &&\n        lastResult.networkStatus !== queryStoreValue.networkStatus\n      );\n\n      const shouldNotifyIfLoading =\n        options.returnPartialData ||\n        (!newData && queryStoreValue.previousVariables) ||\n        (networkStatusChanged && options.notifyOnNetworkStatusChange) ||\n        fetchPolicy === 'cache-only' ||\n        fetchPolicy === 'cache-and-network';\n\n      if (loading && !shouldNotifyIfLoading) {\n        return;\n      }\n\n      const hasGraphQLErrors = isNonEmptyArray(queryStoreValue.graphQLErrors);\n\n      const errorPolicy: ErrorPolicy = observableQuery\n        && observableQuery.options.errorPolicy\n        || options.errorPolicy\n        || 'none';\n\n      // If we have either a GraphQL error or a network error, we create\n      // an error and tell the observer about it.\n      if (errorPolicy === 'none' && hasGraphQLErrors || queryStoreValue.networkError) {\n        return invoke('error', new ApolloError({\n          graphQLErrors: queryStoreValue.graphQLErrors,\n          networkError: queryStoreValue.networkError,\n        }));\n      }\n\n      try {\n        let data: any;\n        let isMissing: boolean;\n\n        if (newData) {\n          // As long as we're using the cache, clear out the latest\n          // `newData`, since it will now become the current data. We need\n          // to keep the `newData` stored with the query when using\n          // `no-cache` since `getCurrentQueryResult` attemps to pull from\n          // `newData` first, following by trying the cache (which won't\n          // find a hit for `no-cache`).\n          if (fetchPolicy !== 'no-cache' && fetchPolicy !== 'network-only') {\n            this.setQuery(queryId, () => ({ newData: null }));\n          }\n\n          data = newData.result;\n          isMissing = !newData.complete;\n        } else {\n          const lastError = observableQuery && observableQuery.getLastError();\n          const errorStatusChanged =\n            errorPolicy !== 'none' &&\n            (lastError && lastError.graphQLErrors) !==\n              queryStoreValue.graphQLErrors;\n\n          if (lastResult && lastResult.data && !errorStatusChanged) {\n            data = lastResult.data;\n            isMissing = false;\n          } else {\n            const diffResult = this.dataStore.getCache().diff({\n              query: document as DocumentNode,\n              variables:\n                queryStoreValue.previousVariables ||\n                queryStoreValue.variables,\n              returnPartialData: true,\n              optimistic: true,\n            });\n\n            data = diffResult.result;\n            isMissing = !diffResult.complete;\n          }\n        }\n\n        // If there is some data missing and the user has told us that they\n        // do not tolerate partial data then we want to return the previous\n        // result and mark it as stale.\n        const stale = isMissing && !(\n          options.returnPartialData ||\n          fetchPolicy === 'cache-only'\n        );\n\n        const resultFromStore: ApolloQueryResult<T> = {\n          data: stale ? lastResult && lastResult.data : data,\n          loading,\n          networkStatus: queryStoreValue.networkStatus,\n          stale,\n        };\n\n        // if the query wants updates on errors we need to add it to the result\n        if (errorPolicy === 'all' && hasGraphQLErrors) {\n          resultFromStore.errors = queryStoreValue.graphQLErrors;\n        }\n\n        invoke('next', resultFromStore);\n\n      } catch (networkError) {\n        invoke('error', new ApolloError({ networkError }));\n      }\n    };\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const cache = this.dataStore.getCache();\n      const transformed = cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  // The shouldSubscribe option is a temporary fix that tells us whether watchQuery was called\n  // directly (i.e. through ApolloClient) or through the query method within QueryManager.\n  // Currently, the query method uses watchQuery in order to handle non-network errors correctly\n  // but we don't want to keep track observables issued for the query method since those aren't\n  // supposed to be refetched in the event of a store reset. Once we unify error handling for\n  // network errors and non-network errors, the shouldSubscribe option will go away.\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions,\n    shouldSubscribe = true,\n  ): ObservableQuery<T, TVariables> {\n    invariant(\n      options.fetchPolicy !== 'standby',\n      'client.watchQuery cannot be called with fetchPolicy set to \"standby\"',\n    );\n\n    // assign variable default values if supplied\n    options.variables = this.getVariables(options.query, options.variables);\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    let transformedOptions = { ...options } as WatchQueryOptions<TVariables>;\n\n    return new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      options: transformedOptions,\n      shouldSubscribe: shouldSubscribe,\n    });\n  }\n\n  public query<T>(options: QueryOptions): Promise<ApolloQueryResult<T>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const watchedQuery = this.watchQuery<T>(options, false);\n      this.fetchQueryRejectFns.set(`query:${watchedQuery.queryId}`, reject);\n      watchedQuery\n        .result()\n        .then(resolve, reject)\n        // Since neither resolve nor reject throw or return a value, this .then\n        // handler is guaranteed to execute. Note that it doesn't really matter\n        // when we remove the reject function from this.fetchQueryRejectFns,\n        // since resolve and reject are mutually idempotent. In fact, it would\n        // not be incorrect to let reject functions accumulate over time; it's\n        // just a waste of memory.\n        .then(() =>\n          this.fetchQueryRejectFns.delete(`query:${watchedQuery.queryId}`),\n        );\n    });\n  }\n\n  public generateQueryId() {\n    return String(this.idCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    this.stopPollingQuery(queryId);\n    this.queryStore.stopQuery(queryId);\n    this.invalidate(queryId);\n  }\n\n  public addQueryListener(queryId: string, listener: QueryListener) {\n    this.setQuery(queryId, ({ listeners }) => {\n      listeners.add(listener);\n      return { invalidated: false };\n    });\n  }\n\n  public updateQueryWatch(\n    queryId: string,\n    document: DocumentNode,\n    options: WatchQueryOptions,\n  ) {\n    const { cancel } = this.getQuery(queryId);\n    if (cancel) cancel();\n    const previousResult = () => {\n      let previousResult = null;\n      const { observableQuery } = this.getQuery(queryId);\n      if (observableQuery) {\n        const lastResult = observableQuery.getLastResult();\n        if (lastResult) {\n          previousResult = lastResult.data;\n        }\n      }\n\n      return previousResult;\n    };\n    return this.dataStore.getCache().watch({\n      query: document as DocumentNode,\n      variables: options.variables,\n      optimistic: true,\n      previousResult,\n      callback: newData => {\n        this.setQuery(queryId, () => ({ invalidated: true, newData }));\n      },\n    });\n  }\n\n  // Adds an ObservableQuery to this.observableQueries and to this.observableQueriesByName.\n  public addObservableQuery<T>(\n    queryId: string,\n    observableQuery: ObservableQuery<T>,\n  ) {\n    this.setQuery(queryId, () => ({ observableQuery }));\n  }\n\n  public removeObservableQuery(queryId: string) {\n    const { cancel } = this.getQuery(queryId);\n    this.setQuery(queryId, () => ({ observableQuery: null }));\n    if (cancel) cancel();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store,\n    // we can no longer rely on the results returned by in-flight\n    // requests since these may depend on values that previously existed\n    // in the data portion of the store. So, we cancel the promises and observers\n    // that we have issued so far and not yet resolved (in the case of\n    // queries).\n    this.fetchQueryRejectFns.forEach(reject => {\n      reject(new InvariantError(\n        'Store reset while query was in flight (not completed in link chain)',\n      ));\n    });\n\n    const resetIds: string[] = [];\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) resetIds.push(queryId);\n    });\n\n    this.queryStore.reset(resetIds);\n    this.mutationStore.reset();\n\n    // begin removing data from the store\n    return this.dataStore.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.setQuery(queryId, () => ({ newData: null }));\n        this.invalidate(queryId);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public observeQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    observer: Observer<ApolloQueryResult<T>>,\n  ) {\n    this.addQueryListener(\n      queryId,\n      this.queryListenerForObserver(queryId, options, observer),\n    );\n    return this.fetchQuery<T>(queryId, options);\n  }\n\n  public startQuery<T>(\n    queryId: string,\n    options: WatchQueryOptions,\n    listener: QueryListener,\n  ) {\n    invariant.warn(\"The QueryManager.startQuery method has been deprecated\");\n\n    this.addQueryListener(queryId, listener);\n\n    this.fetchQuery<T>(queryId, options)\n      // `fetchQuery` returns a Promise. In case of a failure it should be caucht or else the\n      // console will show an `Uncaught (in promise)` message. Ignore the error for now.\n      .catch(() => undefined);\n\n    return queryId;\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    variables,\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        {},\n        variables,\n        false,\n      ).map(result => {\n        if (!fetchPolicy || fetchPolicy !== 'no-cache') {\n          this.dataStore.markSubscriptionResult(\n            result,\n            query,\n            variables,\n          );\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: Subscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchQueryRejectFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchQueryRejectFns.delete(`query:${queryId}`);\n    this.fetchQueryRejectFns.delete(`fetchRequest:${queryId}`);\n    this.getQuery(queryId).subscriptions.forEach(x => x.unsubscribe());\n    this.queries.delete(queryId);\n  }\n\n  public getCurrentQueryResult<T>(\n    observableQuery: ObservableQuery<T>,\n    optimistic: boolean = true,\n  ): {\n    data: T | undefined;\n    partial: boolean;\n  } {\n    const { variables, query, fetchPolicy, returnPartialData } = observableQuery.options;\n    const lastResult = observableQuery.getLastResult();\n    const { newData } = this.getQuery(observableQuery.queryId);\n\n    if (newData && newData.complete) {\n      return { data: newData.result, partial: false };\n    }\n\n    if (fetchPolicy === 'no-cache' || fetchPolicy === 'network-only') {\n      return { data: undefined, partial: false };\n    }\n\n    const { result, complete } = this.dataStore.getCache().diff<T>({\n      query,\n      variables,\n      previousResult: lastResult ? lastResult.data : undefined,\n      returnPartialData: true,\n      optimistic,\n    });\n\n    return {\n      data: (complete || returnPartialData) ? result : void 0,\n      partial: !complete,\n    };\n  }\n\n  public getQueryWithPreviousResult<TData, TVariables = OperationVariables>(\n    queryIdOrObservable: string | ObservableQuery<TData, TVariables>,\n  ): {\n    previousResult: any;\n    variables: TVariables | undefined;\n    document: DocumentNode;\n  } {\n    let observableQuery: ObservableQuery<TData, any>;\n    if (typeof queryIdOrObservable === 'string') {\n      const { observableQuery: foundObserveableQuery } = this.getQuery(\n        queryIdOrObservable,\n      );\n      invariant(\n        foundObserveableQuery,\n        `ObservableQuery with this id doesn't exist: ${queryIdOrObservable}`\n      );\n      observableQuery = foundObserveableQuery!;\n    } else {\n      observableQuery = queryIdOrObservable;\n    }\n\n    const { variables, query } = observableQuery.options;\n    return {\n      previousResult: this.getCurrentQueryResult(observableQuery, false).data,\n      variables,\n      document: query,\n    };\n  }\n\n  public broadcastQueries() {\n    this.onBroadcast();\n    this.queries.forEach((info, id) => {\n      if (info.invalidated) {\n        info.listeners.forEach(listener => {\n          // it's possible for the listener to be undefined if the query is being stopped\n          // See here for more detail: https://github.com/apollostack/apollo-client/issues/231\n          if (listener) {\n            listener(this.queryStore.get(id), info.newData);\n          }\n        });\n      }\n    });\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean = this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          byVariables.set(\n            varJson,\n            observable = multiplex(\n              execute(link, operation) as Observable<FetchResult<T>>\n            )\n          );\n\n          const cleanup = () => {\n            byVariables.delete(varJson);\n            if (!byVariables.size) inFlightLinkObservables.delete(serverQuery);\n            cleanupSub.unsubscribe();\n          };\n\n          const cleanupSub = observable.subscribe({\n            next: cleanup,\n            error: cleanup,\n            complete: cleanup,\n          });\n        }\n\n      } else {\n        observable = multiplex(execute(link, operation) as Observable<FetchResult<T>>);\n      }\n    } else {\n      observable = Observable.of({ data: {} } as FetchResult<T>);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  // Takes a request id, query id, a query document and information associated with the query\n  // and send it to the network interface. Returns\n  // a promise for the result associated with that request.\n  private fetchRequest<T>({\n    requestId,\n    queryId,\n    document,\n    options,\n    fetchMoreForQueryId,\n  }: {\n    requestId: number;\n    queryId: string;\n    document: DocumentNode;\n    options: WatchQueryOptions;\n    fetchMoreForQueryId?: string;\n  }): Promise<FetchResult<T>> {\n    const { variables, errorPolicy = 'none', fetchPolicy } = options;\n    let resultFromStore: any;\n    let errorsFromStore: any;\n\n    return new Promise<ApolloQueryResult<T>>((resolve, reject) => {\n      const observable = this.getObservableFromLink(\n        document,\n        options.context,\n        variables,\n      );\n\n      const fqrfId = `fetchRequest:${queryId}`;\n      this.fetchQueryRejectFns.set(fqrfId, reject);\n\n      const cleanup = () => {\n        this.fetchQueryRejectFns.delete(fqrfId);\n        this.setQuery(queryId, ({ subscriptions }) => {\n          subscriptions.delete(subscription);\n        });\n      };\n\n      const subscription = observable.map((result: FetchResult<T>) => {\n        if (requestId >= this.getQuery(queryId).lastRequestId) {\n          this.markQueryResult(\n            queryId,\n            result,\n            options,\n            fetchMoreForQueryId,\n          );\n\n          this.queryStore.markQueryResult(\n            queryId,\n            result,\n            fetchMoreForQueryId,\n          );\n\n          this.invalidate(queryId);\n          this.invalidate(fetchMoreForQueryId);\n\n          this.broadcastQueries();\n        }\n\n        if (errorPolicy === 'none' && isNonEmptyArray(result.errors)) {\n          return reject(new ApolloError({\n            graphQLErrors: result.errors,\n          }));\n        }\n\n        if (errorPolicy === 'all') {\n          errorsFromStore = result.errors;\n        }\n\n        if (fetchMoreForQueryId || fetchPolicy === 'no-cache') {\n          // We don't write fetchMore results to the store because this would overwrite\n          // the original result in case an @connection directive is used.\n          resultFromStore = result.data;\n        } else {\n          // ensure result is combined with data already in store\n          const { result, complete } = this.dataStore.getCache().diff<T>({\n            variables,\n            query: document,\n            optimistic: false,\n            returnPartialData: true,\n          });\n\n          if (complete || options.returnPartialData) {\n            resultFromStore = result;\n          }\n        }\n      }).subscribe({\n        error(error: ApolloError) {\n          cleanup();\n          reject(error);\n        },\n\n        complete() {\n          cleanup();\n          resolve({\n            data: resultFromStore,\n            errors: errorsFromStore,\n            loading: false,\n            networkStatus: NetworkStatus.ready,\n            stale: false,\n          });\n        },\n      });\n\n      this.setQuery(queryId, ({ subscriptions }) => {\n        subscriptions.add(subscription);\n      });\n    });\n  }\n\n  private getQuery(queryId: string) {\n    return (\n      this.queries.get(queryId) || {\n        listeners: new Set<QueryListener>(),\n        invalidated: false,\n        document: null,\n        newData: null,\n        lastRequestId: 1,\n        observableQuery: null,\n        subscriptions: new Set<Subscription>(),\n      }\n    );\n  }\n\n  private setQuery<T extends keyof QueryInfo>(\n    queryId: string,\n    updater: (prev: QueryInfo) => Pick<QueryInfo, T> | void,\n  ) {\n    const prev = this.getQuery(queryId);\n    const newInfo = { ...prev, ...updater(prev) };\n    this.queries.set(queryId, newInfo);\n  }\n\n  private invalidate(\n    queryId: string | undefined,\n    invalidated = true,\n  ) {\n    if (queryId) {\n      this.setQuery(queryId, () => ({ invalidated }));\n    }\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n\n  public checkInFlight(queryId: string) {\n    const query = this.queryStore.get(queryId);\n\n    return (\n      query &&\n      query.networkStatus !== NetworkStatus.ready &&\n      query.networkStatus !== NetworkStatus.error\n    );\n  }\n\n  // Map from client ID to { interval, options }.\n  private pollingInfoByQueryId = new Map<string, {\n    interval: number;\n    timeout: NodeJS.Timeout;\n    options: WatchQueryOptions;\n  }>();\n\n  public startPollingQuery(\n    options: WatchQueryOptions,\n    queryId: string,\n    listener?: QueryListener,\n  ): string {\n    const { pollInterval } = options;\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Do not poll in SSR mode\n    if (!this.ssrMode) {\n      let info = this.pollingInfoByQueryId.get(queryId)!;\n      if (!info) {\n        this.pollingInfoByQueryId.set(queryId, (info = {} as any));\n      }\n\n      info.interval = pollInterval!;\n      info.options = {\n        ...options,\n        fetchPolicy: 'network-only',\n      };\n\n      const maybeFetch = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          if (this.checkInFlight(queryId)) {\n            poll();\n          } else {\n            this.fetchQuery(queryId, info.options, FetchType.poll).then(\n              poll,\n              poll,\n            );\n          }\n        }\n      };\n\n      const poll = () => {\n        const info = this.pollingInfoByQueryId.get(queryId);\n        if (info) {\n          clearTimeout(info.timeout);\n          info.timeout = setTimeout(maybeFetch, info.interval);\n        }\n      };\n\n      if (listener) {\n        this.addQueryListener(queryId, listener);\n      }\n\n      poll();\n    }\n\n    return queryId;\n  }\n\n  public stopPollingQuery(queryId: string) {\n    this.pollingInfoByQueryId.delete(queryId);\n  }\n}\n","import { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, Cache, DataProxy } from 'apollo-cache';\n\nimport { QueryStoreValue } from '../data/queries';\nimport {\n  getOperationName,\n  tryFunctionOrLogError,\n  graphQLResultHasError,\n} from 'apollo-utilities';\nimport { MutationQueryReducer } from '../core/types';\n\nexport type QueryWithUpdater = {\n  updater: MutationQueryReducer<Object>;\n  query: QueryStoreValue;\n};\n\nexport interface DataWrite {\n  rootId: string;\n  result: any;\n  document: DocumentNode;\n  operationName: string | null;\n  variables: Object;\n}\n\nexport class DataStore<TSerialized> {\n  private cache: ApolloCache<TSerialized>;\n\n  constructor(initialCache: ApolloCache<TSerialized>) {\n    this.cache = initialCache;\n  }\n\n  public getCache(): ApolloCache<TSerialized> {\n    return this.cache;\n  }\n\n  public markQueryResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n    fetchMoreForQueryId: string | undefined,\n    ignoreErrors: boolean = false,\n  ) {\n    let writeWithErrors = !graphQLResultHasError(result);\n    if (ignoreErrors && graphQLResultHasError(result) && result.data) {\n      writeWithErrors = true;\n    }\n    if (!fetchMoreForQueryId && writeWithErrors) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_QUERY',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markSubscriptionResult(\n    result: ExecutionResult,\n    document: DocumentNode,\n    variables: any,\n  ) {\n    // the subscription interface should handle not sending us results we no longer subscribe to.\n    // XXX I don't think we ever send in an object with errors, but we might in the future...\n    if (!graphQLResultHasError(result)) {\n      this.cache.write({\n        result: result.data,\n        dataId: 'ROOT_SUBSCRIPTION',\n        query: document,\n        variables: variables,\n      });\n    }\n  }\n\n  public markMutationInit(mutation: {\n    mutationId: string;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n    optimisticResponse: Object | Function | undefined;\n  }) {\n    if (mutation.optimisticResponse) {\n      let optimistic: Object;\n      if (typeof mutation.optimisticResponse === 'function') {\n        optimistic = mutation.optimisticResponse(mutation.variables);\n      } else {\n        optimistic = mutation.optimisticResponse;\n      }\n\n      this.cache.recordOptimisticTransaction(c => {\n        const orig = this.cache;\n        this.cache = c;\n\n        try {\n          this.markMutationResult({\n            mutationId: mutation.mutationId,\n            result: { data: optimistic },\n            document: mutation.document,\n            variables: mutation.variables,\n            updateQueries: mutation.updateQueries,\n            update: mutation.update,\n          });\n        } finally {\n          this.cache = orig;\n        }\n      }, mutation.mutationId);\n    }\n  }\n\n  public markMutationResult(mutation: {\n    mutationId: string;\n    result: ExecutionResult;\n    document: DocumentNode;\n    variables: any;\n    updateQueries: { [queryId: string]: QueryWithUpdater };\n    update: ((proxy: DataProxy, mutationResult: Object) => void) | undefined;\n  }) {\n    // Incorporate the result from this mutation into the store\n    if (!graphQLResultHasError(mutation.result)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        Object.keys(updateQueries).forEach(id => {\n          const { query, updater } = updateQueries[id];\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = this.cache.diff({\n            query: query.document,\n            variables: query.variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = tryFunctionOrLogError(() =>\n              updater(currentQueryResult, {\n                mutationResult: mutation.result,\n                queryName: getOperationName(query.document) || undefined,\n                queryVariables: query.variables,\n              }),\n            );\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: query.document,\n                variables: query.variables,\n              });\n            }\n          }\n        });\n      }\n\n      this.cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          tryFunctionOrLogError(() => update(c, mutation.result));\n        }\n      });\n    }\n  }\n\n  public markMutationComplete({\n    mutationId,\n    optimisticResponse,\n  }: {\n    mutationId: string;\n    optimisticResponse?: any;\n  }) {\n    if (optimisticResponse) {\n      this.cache.removeOptimistic(mutationId);\n    }\n  }\n\n  public markUpdateQueryResult(\n    document: DocumentNode,\n    variables: any,\n    newResult: any,\n  ) {\n    this.cache.write({\n      result: newResult,\n      dataId: 'ROOT_QUERY',\n      variables,\n      query: document,\n    });\n  }\n\n  public reset(): Promise<void> {\n    return this.cache.reset();\n  }\n}\n","export const version = \"2.6.10\"","import {\n  ApolloLink,\n  FetchResult,\n  GraphQLRequest,\n  execute,\n} from 'apollo-link';\nimport { ExecutionResult, DocumentNode } from 'graphql';\nimport { ApolloCache, DataProxy } from 'apollo-cache';\n\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { QueryManager } from './core/QueryManager';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './core/types';\nimport { ObservableQuery } from './core/ObservableQuery';\nimport { LocalState, FragmentMatcher } from './core/LocalState';\nimport { Observable } from './util/Observable';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n} from './core/watchQueryOptions';\n\nimport { DataStore } from './data/store';\n\nimport { version } from './version';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions>;\n  query?: Partial<QueryOptions>;\n  mutate?: Partial<MutationOptions>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport default class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public store: DataStore<TCacheShape>;\n  public cache: ApolloCache<TCacheShape>;\n  public readonly queryManager: QueryManager<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations. Passing\n   *                               `{ freezeResults: true }` to the `InMemoryCache` constructor\n   *                               can help enforce this immutability.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools,\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    // If a link hasn't been defined, but local state resolvers have been set,\n    // setup a default empty link.\n    if (!link && resolvers) {\n      link = ApolloLink.empty();\n    }\n\n    if (!link || !cache) {\n      throw new InvariantError(\n        \"In order to initialize Apollo Client, you must specify 'link' and 'cache' properties in the options object.\\n\" +\n        \"These options are part of the upgrade requirements when migrating from Apollo Client 1.x to Apollo Client 2.x.\\n\" +\n        \"For more information, please visit: https://www.apollographql.com/docs/tutorial/client.html#apollo-client-setup\"\n      );\n    }\n\n    // remove apollo-client supported directives\n    this.link = link;\n    this.cache = cache;\n    this.store = new DataStore(cache);\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    // Attach the client instance to window to let us be found by chrome devtools, but only in\n    // development mode\n    const defaultConnectToDevTools =\n      process.env.NODE_ENV !== 'production' &&\n      typeof window !== 'undefined' &&\n      !(window as any).__APOLLO_CLIENT__;\n\n    if (\n      typeof connectToDevTools === 'undefined'\n        ? defaultConnectToDevTools\n        : connectToDevTools && typeof window !== 'undefined'\n    ) {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self\n      ) {\n        // First check if devtools is not installed\n        if (\n          typeof (window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__ === 'undefined'\n        ) {\n          // Only for Chrome\n          if (\n            window.navigator &&\n            window.navigator.userAgent &&\n            window.navigator.userAgent.indexOf('Chrome') > -1\n          ) {\n            // tslint:disable-next-line\n            console.debug(\n              'Download the Apollo DevTools ' +\n                'for a better development experience: ' +\n                'https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm',\n            );\n          }\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      link: this.link,\n      store: this.store,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.queryStore.getStore(),\n              mutations: this.queryManager.mutationStore.getStore(),\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      },\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = {\n        ...this.defaultOptions.watchQuery,\n        ...options,\n      } as WatchQueryOptions<TVariables>;\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = { ...this.defaultOptions.query, ...options } as QueryOptions<\n        TVariables\n      >;\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = {\n        ...this.defaultOptions.mutate,\n        ...options,\n      } as MutationOptions<T, TVariables>;\n    }\n\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    const result = this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  /**\n   * Sugar for writeQuery & writeFragment\n   * This method will construct a query from the data object passed in.\n   * If no id is supplied, writeData will write the data to the root.\n   * If an id is supplied, writeData will write a fragment to the object\n   * specified by the id in the store.\n   *\n   * Since you aren't passing in a query to check the shape of the data,\n   * you must pass in an object that conforms to the shape of valid GraphQL data.\n   */\n  public writeData<TData = any>(\n    options: DataProxy.WriteDataOptions<TData>,\n  ): void {\n    const result = this.cache.writeData<TData>(options);\n    this.queryManager.broadcastQueries();\n    return result;\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * This initializes the query manager that tracks queries and the cache\n   */\n  public initQueryManager(): QueryManager<TCacheShape> {\n    invariant.warn(\n      'Calling the initQueryManager method is no longer necessary, ' +\n        'and it will be removed from ApolloClient in version 3.0.',\n    );\n    return this.queryManager;\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}